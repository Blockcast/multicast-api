// Code generated by xsdgen. DO NOT EDIT.

package models

import (
	"bytes"
	"encoding/base64"
	"encoding/xml"
	"time"
)

type Data struct {
	FilterID string `xml:"filterID,attr" json:"filterID" db:"filterID"`
}

type DeliveryInfo struct {
	Start time.Time `xml:"start,attr,omitempty" json:"start,omitempty" db:"start"`
	End   time.Time `xml:"end,attr,omitempty" json:"end,omitempty" db:"end"`
}

func (t *DeliveryInfo) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	type T DeliveryInfo
	var layout struct {
		*T
		Start *xsdDateTime `xml:"start,attr,omitempty" json:"start,omitempty" db:"start"`
		End   *xsdDateTime `xml:"end,attr,omitempty" json:"end,omitempty" db:"end"`
	}
	layout.T = (*T)(t)
	layout.Start = (*xsdDateTime)(&layout.T.Start)
	layout.End = (*xsdDateTime)(&layout.T.End)
	return e.EncodeElement(layout, start)
}
func (t *DeliveryInfo) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T DeliveryInfo
	var overlay struct {
		*T
		Start *xsdDateTime `xml:"start,attr,omitempty" json:"start,omitempty" db:"start"`
		End   *xsdDateTime `xml:"end,attr,omitempty" json:"end,omitempty" db:"end"`
	}
	overlay.T = (*T)(t)
	overlay.Start = (*xsdDateTime)(&overlay.T.Start)
	overlay.End = (*xsdDateTime)(&overlay.T.End)
	return d.DecodeElement(&overlay, &start)
}

type FileSchedule struct {
	Items              []string            `xml:",any"`
	FileURI            FileURI             `xml:"urn:3gpp:metadata:2011:MBMS:scheduleDescription fileURI" json:"fileURI" db:"fileURI"`
	DeliveryInfo       []DeliveryInfo      `xml:"urn:3gpp:metadata:2011:MBMS:scheduleDescription deliveryInfo,omitempty" json:"deliveryInfo,omitempty" db:"deliveryInfo"`
	ReceptionFiltering *ReceptionFiltering `xml:"urn:3gpp:metadata:2012:MBMS:scheduleDescription receptionFiltering,omitempty" json:"receptionFiltering,omitempty" db:"receptionFiltering"`
	Delimiter          byte                `xml:"urn:3gpp:metadata:2009:MBMS:schemaVersion delimiter" json:"delimiter" db:"delimiter"`
	SessionId          string              `xml:"urn:3gpp:metadata:2012:MBMS:scheduleDescription sessionId,attr,omitempty" json:"sessionId,omitempty" db:"sessionId"`
	FileMD5            []byte              `xml:"urn:3gpp:metadata:2012:MBMS:scheduleDescription fileMD5,attr,omitempty" json:"fileMD5,omitempty" db:"fileMD5"`
	UnicastOnly        bool                `xml:"urn:3gpp:metadata:2013:MBMS:scheduleDescription unicastOnly,attr,omitempty" json:"unicastOnly,omitempty" db:"unicastOnly"`
}

func (t *FileSchedule) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	type T FileSchedule
	var layout struct {
		*T
		FileMD5 *xsdBase64Binary `xml:"urn:3gpp:metadata:2012:MBMS:scheduleDescription fileMD5,attr,omitempty" json:"fileMD5,omitempty" db:"fileMD5"`
	}
	layout.T = (*T)(t)
	layout.FileMD5 = (*xsdBase64Binary)(&layout.T.FileMD5)
	return e.EncodeElement(layout, start)
}
func (t *FileSchedule) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T FileSchedule
	var overlay struct {
		*T
		FileMD5     *xsdBase64Binary `xml:"urn:3gpp:metadata:2012:MBMS:scheduleDescription fileMD5,attr,omitempty" json:"fileMD5,omitempty" db:"fileMD5"`
		UnicastOnly *bool            `xml:"urn:3gpp:metadata:2013:MBMS:scheduleDescription unicastOnly,attr,omitempty" json:"unicastOnly,omitempty" db:"unicastOnly"`
	}
	overlay.T = (*T)(t)
	overlay.FileMD5 = (*xsdBase64Binary)(&overlay.T.FileMD5)
	overlay.UnicastOnly = (*bool)(&overlay.T.UnicastOnly)
	return d.DecodeElement(&overlay, &start)
}

type FileURI struct {
	Value     string `xml:",chardata"`
	Cancelled bool   `xml:"cancelled,attr,omitempty" json:"cancelled,omitempty" db:"cancelled"`
}

type ReceptionFiltering struct {
	Data []Data `xml:"urn:3gpp:metadata:2012:MBMS:scheduleDescription data" json:"data" db:"data"`
}

type RecurrenceAndMonitoring struct {
	Items    []string `xml:",any"`
	Interval string   `xml:"urn:3gpp:metadata:2013:MBMS:scheduleDescription interval" json:"interval" db:"interval"`
	Mode     bool     `xml:"mode,attr,omitempty" json:"mode,omitempty" db:"mode"`
}

type ReoccurenceStartStop struct {
	Items                   []string                 `xml:",any"`
	Start                   time.Time                `xml:"urn:3gpp:metadata:2011:MBMS:scheduleDescription start" json:"start" db:"start"`
	Stop                    time.Time                `xml:"urn:3gpp:metadata:2011:MBMS:scheduleDescription stop" json:"stop" db:"stop"`
	ReoccurencePattern      *string                  `xml:"urn:3gpp:metadata:2011:MBMS:scheduleDescription reoccurencePattern,omitempty" json:"reoccurencePattern,omitempty" db:"reoccurencePattern"`
	NumberOfTimes           *uint                    `xml:"urn:3gpp:metadata:2011:MBMS:scheduleDescription numberOfTimes,omitempty" json:"numberOfTimes,omitempty" db:"numberOfTimes"`
	ReoccurenceStopTime     *time.Time               `xml:"urn:3gpp:metadata:2011:MBMS:scheduleDescription reoccurenceStopTime,omitempty" json:"reoccurenceStopTime,omitempty" db:"reoccurenceStopTime"`
	Index                   *uint                    `xml:"urn:3gpp:metadata:2011:MBMS:scheduleDescription index,omitempty" json:"index,omitempty" db:"index"`
	ReceptionFiltering      *ReceptionFiltering      `xml:"urn:3gpp:metadata:2012:MBMS:scheduleDescription receptionFiltering,omitempty" json:"receptionFiltering,omitempty" db:"receptionFiltering"`
	Delimiter               byte                     `xml:"urn:3gpp:metadata:2009:MBMS:schemaVersion delimiter" json:"delimiter" db:"delimiter"`
	FDTInstanceURI          *string                  `xml:"urn:3gpp:metadata:2013:MBMS:scheduleDescription FDTInstanceURI,omitempty" json:"FDTInstanceURI,omitempty" db:"FDTInstanceURI"`
	RecurrenceAndMonitoring *RecurrenceAndMonitoring `xml:"urn:3gpp:metadata:2013:MBMS:scheduleDescription recurrenceAndMonitoring,omitempty" json:"recurrenceAndMonitoring,omitempty" db:"recurrenceAndMonitoring"`
	SessionDescriptionURI   string                   `xml:"urn:3gpp:metadata:2013:MBMS:scheduleDescription sessionDescriptionURI,attr,omitempty" json:"sessionDescriptionURI,omitempty" db:"sessionDescriptionURI"`
}

func (t *ReoccurenceStartStop) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	type T ReoccurenceStartStop
	var layout struct {
		*T
		Start               *xsdDateTime `xml:"urn:3gpp:metadata:2011:MBMS:scheduleDescription start" json:"start" db:"start"`
		Stop                *xsdDateTime `xml:"urn:3gpp:metadata:2011:MBMS:scheduleDescription stop" json:"stop" db:"stop"`
		ReoccurenceStopTime *xsdDateTime `xml:"urn:3gpp:metadata:2011:MBMS:scheduleDescription reoccurenceStopTime,omitempty" json:"reoccurenceStopTime,omitempty" db:"reoccurenceStopTime"`
	}
	layout.T = (*T)(t)
	layout.Start = (*xsdDateTime)(&layout.T.Start)
	layout.Stop = (*xsdDateTime)(&layout.T.Stop)
	layout.ReoccurenceStopTime = (*xsdDateTime)(layout.T.ReoccurenceStopTime)
	return e.EncodeElement(layout, start)
}
func (t *ReoccurenceStartStop) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T ReoccurenceStartStop
	var overlay struct {
		*T
		Start               *xsdDateTime `xml:"urn:3gpp:metadata:2011:MBMS:scheduleDescription start" json:"start" db:"start"`
		Stop                *xsdDateTime `xml:"urn:3gpp:metadata:2011:MBMS:scheduleDescription stop" json:"stop" db:"stop"`
		ReoccurenceStopTime *xsdDateTime `xml:"urn:3gpp:metadata:2011:MBMS:scheduleDescription reoccurenceStopTime,omitempty" json:"reoccurenceStopTime,omitempty" db:"reoccurenceStopTime"`
	}
	overlay.T = (*T)(t)
	overlay.Start = (*xsdDateTime)(&overlay.T.Start)
	overlay.Stop = (*xsdDateTime)(&overlay.T.Stop)
	overlay.ReoccurenceStopTime = (*xsdDateTime)(overlay.T.ReoccurenceStopTime)
	return d.DecodeElement(&overlay, &start)
}

type ScheduleDescription struct {
	Items                      []string          `xml:",any"`
	SchemaVersion              uint              `xml:"urn:3gpp:metadata:2009:MBMS:schemaVersion schemaVersion" json:"schemaVersion" db:"schemaVersion"`
	ServiceSchedule            []ServiceSchedule `xml:"urn:3gpp:metadata:2011:MBMS:scheduleDescription serviceSchedule" json:"serviceSchedule" db:"serviceSchedule"`
	ScheduleUpdate             time.Time         `xml:"scheduleUpdate,attr,omitempty" json:"scheduleUpdate,omitempty" db:"scheduleUpdate"`
	FilterDescriptionReference string            `xml:"urn:3gpp:metadata:2012:MBMS:scheduleDescription filterDescriptionReference,attr,omitempty" json:"filterDescriptionReference,omitempty" db:"filterDescriptionReference"`
}

func (t *ScheduleDescription) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	type T ScheduleDescription
	var layout struct {
		*T
		ScheduleUpdate *xsdDateTime `xml:"scheduleUpdate,attr,omitempty" json:"scheduleUpdate,omitempty" db:"scheduleUpdate"`
	}
	layout.T = (*T)(t)
	layout.ScheduleUpdate = (*xsdDateTime)(&layout.T.ScheduleUpdate)
	return e.EncodeElement(layout, start)
}
func (t *ScheduleDescription) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T ScheduleDescription
	var overlay struct {
		*T
		ScheduleUpdate *xsdDateTime `xml:"scheduleUpdate,attr,omitempty" json:"scheduleUpdate,omitempty" db:"scheduleUpdate"`
	}
	overlay.T = (*T)(t)
	overlay.ScheduleUpdate = (*xsdDateTime)(&overlay.T.ScheduleUpdate)
	return d.DecodeElement(&overlay, &start)
}

type ServiceSchedule struct {
	Items                   []string                  `xml:",any"`
	SessionSchedule         []ReoccurenceStartStop    `xml:"urn:3gpp:metadata:2011:MBMS:scheduleDescription sessionSchedule,omitempty" json:"sessionSchedule,omitempty" db:"sessionSchedule"`
	SessionScheduleOverride []SessionScheduleOverride `xml:"urn:3gpp:metadata:2011:MBMS:scheduleDescription sessionScheduleOverride,omitempty" json:"sessionScheduleOverride,omitempty" db:"sessionScheduleOverride"`
	FileSchedule            []FileSchedule            `xml:"urn:3gpp:metadata:2011:MBMS:scheduleDescription fileSchedule,omitempty" json:"fileSchedule,omitempty" db:"fileSchedule"`
	ServiceId               string                    `xml:"serviceId,attr,omitempty" json:"serviceId,omitempty" db:"serviceId"`
	ServiceClass            string                    `xml:"serviceClass,attr,omitempty" json:"serviceClass,omitempty" db:"serviceClass"`
}

type SessionScheduleOverride struct {
	Start     time.Time `xml:"urn:3gpp:metadata:2011:MBMS:scheduleDescription start" json:"start" db:"start"`
	Stop      time.Time `xml:"urn:3gpp:metadata:2011:MBMS:scheduleDescription stop" json:"stop" db:"stop"`
	Index     uint      `xml:"index,attr" json:"index" db:"index"`
	Cancelled bool      `xml:"cancelled,attr,omitempty" json:"cancelled,omitempty" db:"cancelled"`
}

func (t *SessionScheduleOverride) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	type T SessionScheduleOverride
	var layout struct {
		*T
		Start *xsdDateTime `xml:"urn:3gpp:metadata:2011:MBMS:scheduleDescription start" json:"start" db:"start"`
		Stop  *xsdDateTime `xml:"urn:3gpp:metadata:2011:MBMS:scheduleDescription stop" json:"stop" db:"stop"`
	}
	layout.T = (*T)(t)
	layout.Start = (*xsdDateTime)(&layout.T.Start)
	layout.Stop = (*xsdDateTime)(&layout.T.Stop)
	return e.EncodeElement(layout, start)
}
func (t *SessionScheduleOverride) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T SessionScheduleOverride
	var overlay struct {
		*T
		Start *xsdDateTime `xml:"urn:3gpp:metadata:2011:MBMS:scheduleDescription start" json:"start" db:"start"`
		Stop  *xsdDateTime `xml:"urn:3gpp:metadata:2011:MBMS:scheduleDescription stop" json:"stop" db:"stop"`
	}
	overlay.T = (*T)(t)
	overlay.Start = (*xsdDateTime)(&overlay.T.Start)
	overlay.Stop = (*xsdDateTime)(&overlay.T.Stop)
	return d.DecodeElement(&overlay, &start)
}

type xsdBase64Binary []byte

func (b *xsdBase64Binary) UnmarshalText(text []byte) (err error) {
	*b, err = base64.StdEncoding.DecodeString(string(text))
	return
}
func (b xsdBase64Binary) MarshalText() ([]byte, error) {
	var buf bytes.Buffer
	enc := base64.NewEncoder(base64.StdEncoding, &buf)
	enc.Write([]byte(b))
	enc.Close()
	return buf.Bytes(), nil
}

type xsdDateTime time.Time

func (t *xsdDateTime) UnmarshalText(text []byte) error {
	return _unmarshalTime(text, (*time.Time)(t), "2006-01-02T15:04:05.999999999")
}
func (t xsdDateTime) MarshalText() ([]byte, error) {
	return _marshalTime((time.Time)(t), "2006-01-02T15:04:05.999999999")
}
func (t xsdDateTime) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if (time.Time)(t).IsZero() {
		return nil
	}
	m, err := t.MarshalText()
	if err != nil {
		return err
	}
	return e.EncodeElement(m, start)
}
func (t xsdDateTime) MarshalXMLAttr(name xml.Name) (xml.Attr, error) {
	if (time.Time)(t).IsZero() {
		return xml.Attr{}, nil
	}
	m, err := t.MarshalText()
	return xml.Attr{Name: name, Value: string(m)}, err
}
func _unmarshalTime(text []byte, t *time.Time, format string) (err error) {
	s := string(bytes.TrimSpace(text))
	*t, err = time.Parse(format, s)
	if _, ok := err.(*time.ParseError); ok {
		*t, err = time.Parse(format+"Z07:00", s)
	}
	return err
}
func _marshalTime(t time.Time, format string) ([]byte, error) {
	return []byte(t.Format(format + "Z07:00")), nil
}
