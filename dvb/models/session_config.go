// Code generated by xsdgen. DO NOT EDIT.

package models

import (
	"bytes"
	"database/sql/driver"
	"encoding/base64"
	"encoding/hex"
	"encoding/xml"
	"fmt"
	"strconv"
	"strings"
)

type ActionTime struct {
	MediaTime   *MediaTimeType `xml:"urn:mpeg:mpeg7:schema:2001 MediaTime,omitempty" json:"MediaTime,omitempty" db:"MediaTime"`
	GeneralTime *TimeType      `xml:"urn:mpeg:mpeg7:schema:2001 GeneralTime,omitempty" json:"GeneralTime,omitempty" db:"GeneralTime"`
}

type AdministrativeUnit struct {
	Value string `xml:",chardata"`
	Type  string `xml:"type,attr,omitempty" json:"type,omitempty" db:"type"`
}

type Affiliation struct {
	Organization    *OrganizationType `xml:"urn:mpeg:mpeg7:schema:2001 Organization,omitempty" json:"Organization,omitempty" db:"Organization"`
	OrganizationRef *ReferenceType    `xml:"urn:mpeg:mpeg7:schema:2001 OrganizationRef,omitempty" json:"OrganizationRef,omitempty" db:"OrganizationRef"`
	PersonGroup     *PersonGroupType  `xml:"urn:mpeg:mpeg7:schema:2001 PersonGroup,omitempty" json:"PersonGroup,omitempty" db:"PersonGroup"`
	PersonGroupRef  *ReferenceType    `xml:"urn:mpeg:mpeg7:schema:2001 PersonGroupRef,omitempty" json:"PersonGroupRef,omitempty" db:"PersonGroupRef"`
}

type AgentType struct {
	Icon     []MediaLocatorType `xml:"urn:mpeg:mpeg7:schema:2001 Icon,omitempty" json:"Icon,omitempty" db:"Icon"`
	TimeBase string             `xml:"timeBase,attr,omitempty" json:"timeBase,omitempty" db:"timeBase"`
	TimeUnit DurationType       `xml:"timeUnit,attr,omitempty" json:"timeUnit,omitempty" db:"timeUnit"`
}

// Must match the pattern :[^:]+:[^:]+
type Anon1 string

type Anon10 struct {
	TimePoint        *TimePointType        `xml:"urn:mpeg:mpeg7:schema:2001 TimePoint,omitempty" json:"TimePoint,omitempty" db:"TimePoint"`
	RelTimePoint     *RelTimePointType     `xml:"urn:mpeg:mpeg7:schema:2001 RelTimePoint,omitempty" json:"RelTimePoint,omitempty" db:"RelTimePoint"`
	RelIncrTimePoint *RelIncrTimePointType `xml:"urn:mpeg:mpeg7:schema:2001 RelIncrTimePoint,omitempty" json:"RelIncrTimePoint,omitempty" db:"RelIncrTimePoint"`
	Duration         *DurationType         `xml:"urn:mpeg:mpeg7:schema:2001 Duration,omitempty" json:"Duration,omitempty" db:"Duration"`
	IncrDuration     *IncrDurationType     `xml:"urn:mpeg:mpeg7:schema:2001 IncrDuration,omitempty" json:"IncrDuration,omitempty" db:"IncrDuration"`
	PreferenceValue  int                   `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
}

func (t *Anon10) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T Anon10
	var overlay struct {
		*T
		PreferenceValue *int `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
	}
	overlay.T = (*T)(t)
	overlay.PreferenceValue = (*int)(&overlay.T.PreferenceValue)
	return d.DecodeElement(&overlay, &start)
}

type Anon11 struct {
	Value string `xml:",chardata"`
	Type  Type   `xml:"type,attr,omitempty" json:"type,omitempty" db:"type"`
	Lang  Lang   `xml:"http://www.w3.org/XML/1998/namespace lang,attr,omitempty" json:"lang,omitempty" db:"lang"`
}

type Anon13 struct {
	Value string `xml:",chardata"`
	Type  Type   `xml:"type,attr,omitempty" json:"type,omitempty" db:"type"`
	Lang  Lang   `xml:"http://www.w3.org/XML/1998/namespace lang,attr,omitempty" json:"lang,omitempty" db:"lang"`
}

type Anon15 struct {
	Name       []Name        `xml:"urn:mpeg:mpeg7:schema:2001 Name,omitempty" json:"Name,omitempty" db:"Name"`
	Definition []TextualType `xml:"urn:mpeg:mpeg7:schema:2001 Definition,omitempty" json:"Definition,omitempty" db:"Definition"`
	Type       Type          `xml:"type,attr,omitempty" json:"type,omitempty" db:"type"`
}

type Anon17 float32

// May be one of binary, color, graylevel, colorized
type Anon19 string

// May be one of NT, BT, RT, US, UF
type Anon2 string

// May be one of none, 50over15Microseconds, ccittJ17
type Anon20 string

// May be one of none, daily, weekly, monthly, annually
type Anon22 string

type Anon4 struct {
	Length int `xml:"length,attr,omitempty" json:"length,omitempty" db:"length"`
}

type Anon5 struct {
	Value     string `xml:",chardata"`
	Preferred bool   `xml:"preferred,attr,omitempty" json:"preferred,omitempty" db:"preferred"`
	Lang      Lang   `xml:"http://www.w3.org/XML/1998/namespace lang,attr,omitempty" json:"lang,omitempty" db:"lang"`
}

// May be one of main, secondary, alternative, original, popular, opusNumber, songTitle, albumTitle, seriesTitle, episodeTitle
type Anon7 string

// May be one of dubbed, closedCaptions, subTitles, signLanguage, audioDescription
type Anon8 string

// May be one of audio, visual, audioVisual, textual, keyAudioClips, keyVideoClips, keyAudioVisualClips, keyFrames, keySounds, keyThemes
type Anon9 string

type AudioChannels struct {
	Value int `xml:",chardata"`
	Front int `xml:"front,attr,omitempty" json:"front,omitempty" db:"front"`
	Side  int `xml:"side,attr,omitempty" json:"side,omitempty" db:"side"`
	Rear  int `xml:"rear,attr,omitempty" json:"rear,omitempty" db:"rear"`
	Lfe   int `xml:"lfe,attr,omitempty" json:"lfe,omitempty" db:"lfe"`
	Track int `xml:"track,attr,omitempty" json:"track,omitempty" db:"track"`
}

type AudioCoding struct {
	Format        *ControlledTermUseType `xml:"urn:mpeg:mpeg7:schema:2001 Format,omitempty" json:"Format,omitempty" db:"Format"`
	AudioChannels *AudioChannels         `xml:"urn:mpeg:mpeg7:schema:2001 AudioChannels,omitempty" json:"AudioChannels,omitempty" db:"AudioChannels"`
	Sample        *Sample                `xml:"urn:mpeg:mpeg7:schema:2001 Sample,omitempty" json:"Sample,omitempty" db:"Sample"`
	Emphasis      *Emphasis              `xml:"urn:mpeg:mpeg7:schema:2001 Emphasis,omitempty" json:"Emphasis,omitempty" db:"Emphasis"`
	Presentation  *ControlledTermUseType `xml:"urn:mpeg:mpeg7:schema:2001 Presentation,omitempty" json:"Presentation,omitempty" db:"Presentation"`
}

type AuxiliaryLanguageType string

type BaseMulticastTransportSessionType struct {
	TransportProtocol                MulticastTransportProtocolType         `xml:"urn:dvb:metadata:MulticastSessionConfiguration:2019 TransportProtocol" json:"TransportProtocol" db:"TransportProtocol"`
	EndpointAddress                  []MulticastEndpointAddressType         `xml:"urn:dvb:metadata:MulticastSessionConfiguration:2019 EndpointAddress" json:"EndpointAddress" db:"EndpointAddress"`
	BitRate                          BitRateType                            `xml:"urn:dvb:metadata:MulticastSessionConfiguration:2019 BitRate" json:"BitRate" db:"BitRate"`
	ForwardErrorCorrectionParameters []ForwardErrorCorrectionParametersType `xml:"urn:dvb:metadata:MulticastSessionConfiguration:2019 ForwardErrorCorrectionParameters,omitempty" json:"ForwardErrorCorrectionParameters,omitempty" db:"ForwardErrorCorrectionParameters"`
	UnicastRepairParameters          *UnicastRepairParametersType           `xml:"urn:dvb:metadata:MulticastSessionConfiguration:2019 UnicastRepairParameters,omitempty" json:"UnicastRepairParameters,omitempty" db:"UnicastRepairParameters"`
	TransportSecurity                TransportSecurityType                  `xml:"transportSecurity,attr,omitempty" json:"transportSecurity,omitempty" db:"transportSecurity"`
}

func (t *BaseMulticastTransportSessionType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T BaseMulticastTransportSessionType
	var overlay struct {
		*T
		TransportSecurity *TransportSecurityType `xml:"transportSecurity,attr,omitempty" json:"transportSecurity,omitempty" db:"transportSecurity"`
	}
	overlay.T = (*T)(t)
	overlay.TransportSecurity = (*TransportSecurityType)(&overlay.T.TransportSecurity)
	return d.DecodeElement(&overlay, &start)
}

// Must match the pattern \-?P(\d+D)?(T(\d+H)?(\d+M)?(\d+S)?(\d+N)?(\d{2}f)?)?(\d+F)?((\-|\+)\d{2}:\d{2}Z)?
type BasicDurationType string

// Must match the pattern \-?(\d+(\-\d{2}(\-\d{2})?)?)?(T\d{2}(:\d{2}(:\d{2}(:\d+(\.\d{2})?)?)?)?)?(F\d+)?((\-|\+)\d{2}:\d{2})?
type BasicTimePointType string

type BitRate struct {
	Value    int  `xml:",chardata"`
	Variable bool `xml:"variable,attr,omitempty" json:"variable,omitempty" db:"variable"`
	Minimum  int  `xml:"minimum,attr,omitempty" json:"minimum,omitempty" db:"minimum"`
	Average  int  `xml:"average,attr,omitempty" json:"average,omitempty" db:"average"`
	Maximum  int  `xml:"maximum,attr,omitempty" json:"maximum,omitempty" db:"maximum"`
}

func (t *BitRate) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T BitRate
	var overlay struct {
		*T
		Variable *bool `xml:"variable,attr,omitempty" json:"variable,omitempty" db:"variable"`
	}
	overlay.T = (*T)(t)
	overlay.Variable = (*bool)(&overlay.T.Variable)
	return d.DecodeElement(&overlay, &start)
}

type BitRateType struct {
	Average int `xml:"average,attr,omitempty" json:"average,omitempty" db:"average"`
	Maximum int `xml:"maximum,attr" json:"maximum" db:"maximum"`
}

type BrowsingPreferencesType struct {
	SummaryPreferences  []SummaryPreferencesType `xml:"urn:mpeg:mpeg7:schema:2001 SummaryPreferences,omitempty" json:"SummaryPreferences,omitempty" db:"SummaryPreferences"`
	PreferenceCondition []PreferenceCondition    `xml:"urn:mpeg:mpeg7:schema:2001 PreferenceCondition,omitempty" json:"PreferenceCondition,omitempty" db:"PreferenceCondition"`
	Protected           UserChoiceType           `xml:"protected,attr,omitempty" json:"protected,omitempty" db:"protected"`
	PreferenceValue     int                      `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
	TimeBase            string                   `xml:"timeBase,attr,omitempty" json:"timeBase,omitempty" db:"timeBase"`
	TimeUnit            DurationType             `xml:"timeUnit,attr,omitempty" json:"timeUnit,omitempty" db:"timeUnit"`
}

func (t *BrowsingPreferencesType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T BrowsingPreferencesType
	var overlay struct {
		*T
		Protected       *UserChoiceType `xml:"protected,attr,omitempty" json:"protected,omitempty" db:"protected"`
		PreferenceValue *int            `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
	}
	overlay.T = (*T)(t)
	overlay.Protected = (*UserChoiceType)(&overlay.T.Protected)
	overlay.PreferenceValue = (*int)(&overlay.T.PreferenceValue)
	return d.DecodeElement(&overlay, &start)
}

type BytePosition struct {
	Length int `xml:"length,attr,omitempty" json:"length,omitempty" db:"length"`
}

type CaptionLanguage struct {
	Value           string `xml:",chardata"`
	PreferenceValue int    `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
}

func (t *CaptionLanguage) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T CaptionLanguage
	var overlay struct {
		*T
		PreferenceValue *int `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
	}
	overlay.T = (*T)(t)
	overlay.PreferenceValue = (*int)(&overlay.T.PreferenceValue)
	return d.DecodeElement(&overlay, &start)
}

type ClassificationPreferencesType struct {
	Country          []Country          `xml:"urn:mpeg:mpeg7:schema:2001 Country,omitempty" json:"Country,omitempty" db:"Country"`
	DatePeriod       []DatePeriod       `xml:"urn:mpeg:mpeg7:schema:2001 DatePeriod,omitempty" json:"DatePeriod,omitempty" db:"DatePeriod"`
	LanguageFormat   []LanguageFormat   `xml:"urn:mpeg:mpeg7:schema:2001 LanguageFormat,omitempty" json:"LanguageFormat,omitempty" db:"LanguageFormat"`
	Language         []Language         `xml:"urn:mpeg:mpeg7:schema:2001 Language,omitempty" json:"Language,omitempty" db:"Language"`
	CaptionLanguage  []CaptionLanguage  `xml:"urn:mpeg:mpeg7:schema:2001 CaptionLanguage,omitempty" json:"CaptionLanguage,omitempty" db:"CaptionLanguage"`
	Form             []Form             `xml:"urn:mpeg:mpeg7:schema:2001 Form,omitempty" json:"Form,omitempty" db:"Form"`
	Genre            []Genre            `xml:"urn:mpeg:mpeg7:schema:2001 Genre,omitempty" json:"Genre,omitempty" db:"Genre"`
	Subject          []Subject          `xml:"urn:mpeg:mpeg7:schema:2001 Subject,omitempty" json:"Subject,omitempty" db:"Subject"`
	Review           []Review           `xml:"urn:mpeg:mpeg7:schema:2001 Review,omitempty" json:"Review,omitempty" db:"Review"`
	ParentalGuidance []ParentalGuidance `xml:"urn:mpeg:mpeg7:schema:2001 ParentalGuidance,omitempty" json:"ParentalGuidance,omitempty" db:"ParentalGuidance"`
	PreferenceValue  int                `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
	TimeBase         string             `xml:"timeBase,attr,omitempty" json:"timeBase,omitempty" db:"timeBase"`
	TimeUnit         DurationType       `xml:"timeUnit,attr,omitempty" json:"timeUnit,omitempty" db:"timeUnit"`
}

func (t *ClassificationPreferencesType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T ClassificationPreferencesType
	var overlay struct {
		*T
		PreferenceValue *int `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
	}
	overlay.T = (*T)(t)
	overlay.PreferenceValue = (*int)(&overlay.T.PreferenceValue)
	return d.DecodeElement(&overlay, &start)
}

type ClassificationSchemeAliasType struct {
	Alias string `xml:"alias,attr" json:"alias" db:"alias"`
}

type ClassificationSchemeBaseType struct {
	Import   []ReferenceType `xml:"urn:mpeg:mpeg7:schema:2001 Import,omitempty" json:"Import,omitempty" db:"Import"`
	Uri      string          `xml:"uri,attr" json:"uri" db:"uri"`
	Domain   Domain          `xml:"domain,attr,omitempty" json:"domain,omitempty" db:"domain"`
	TimeBase string          `xml:"timeBase,attr,omitempty" json:"timeBase,omitempty" db:"timeBase"`
	TimeUnit DurationType    `xml:"timeUnit,attr,omitempty" json:"timeUnit,omitempty" db:"timeUnit"`
}

type ClassificationSchemeType struct {
	Import   []ReferenceType      `xml:"urn:mpeg:mpeg7:schema:2001 Import,omitempty" json:"Import,omitempty" db:"Import"`
	Term     []TermDefinitionType `xml:"urn:mpeg:mpeg7:schema:2001 Term" json:"Term" db:"Term"`
	Uri      string               `xml:"uri,attr" json:"uri" db:"uri"`
	Domain   Domain               `xml:"domain,attr,omitempty" json:"domain,omitempty" db:"domain"`
	TimeBase string               `xml:"timeBase,attr,omitempty" json:"timeBase,omitempty" db:"timeBase"`
	TimeUnit DurationType         `xml:"timeUnit,attr,omitempty" json:"timeUnit,omitempty" db:"timeUnit"`
}

type ColorDomain string

// May be one of push, pull
type ContentAcquisitionMethodType string

type ControlledTermUseType struct {
	Name       []Name        `xml:"urn:mpeg:mpeg7:schema:2001 Name,omitempty" json:"Name,omitempty" db:"Name"`
	Definition []TextualType `xml:"urn:mpeg:mpeg7:schema:2001 Definition,omitempty" json:"Definition,omitempty" db:"Definition"`
}

type Country struct {
	CountryCode     CountryCode `xml:",chardata"`
	PreferenceValue int         `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
}

func (t *Country) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T Country
	var overlay struct {
		*T
		PreferenceValue *int `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
	}
	overlay.T = (*T)(t)
	overlay.PreferenceValue = (*int)(&overlay.T.PreferenceValue)
	return d.DecodeElement(&overlay, &start)
}

// Must match the pattern [a-zA-Z]{2}
type CountryCode string

type CreationPreferencesType struct {
	Title           []Title      `xml:"urn:mpeg:mpeg7:schema:2001 Title,omitempty" json:"Title,omitempty" db:"Title"`
	Creator         []Creator    `xml:"urn:mpeg:mpeg7:schema:2001 Creator,omitempty" json:"Creator,omitempty" db:"Creator"`
	Keyword         []Keyword    `xml:"urn:mpeg:mpeg7:schema:2001 Keyword,omitempty" json:"Keyword,omitempty" db:"Keyword"`
	Location        []Location   `xml:"urn:mpeg:mpeg7:schema:2001 Location,omitempty" json:"Location,omitempty" db:"Location"`
	DatePeriod      []Anon10     `xml:"urn:mpeg:mpeg7:schema:2001 DatePeriod,omitempty" json:"DatePeriod,omitempty" db:"DatePeriod"`
	Tool            []Tool       `xml:"urn:mpeg:mpeg7:schema:2001 Tool,omitempty" json:"Tool,omitempty" db:"Tool"`
	PreferenceValue int          `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
	TimeBase        string       `xml:"timeBase,attr,omitempty" json:"timeBase,omitempty" db:"timeBase"`
	TimeUnit        DurationType `xml:"timeUnit,attr,omitempty" json:"timeUnit,omitempty" db:"timeUnit"`
}

func (t *CreationPreferencesType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T CreationPreferencesType
	var overlay struct {
		*T
		PreferenceValue *int `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
	}
	overlay.T = (*T)(t)
	overlay.PreferenceValue = (*int)(&overlay.T.PreferenceValue)
	return d.DecodeElement(&overlay, &start)
}

type Creator struct {
	Role            ControlledTermUseType `xml:"urn:mpeg:mpeg7:schema:2001 Role" json:"Role" db:"Role"`
	Agent           *AgentType            `xml:"urn:mpeg:mpeg7:schema:2001 Agent,omitempty" json:"Agent,omitempty" db:"Agent"`
	AgentRef        *ReferenceType        `xml:"urn:mpeg:mpeg7:schema:2001 AgentRef,omitempty" json:"AgentRef,omitempty" db:"AgentRef"`
	Character       []PersonNameType      `xml:"urn:mpeg:mpeg7:schema:2001 Character,omitempty" json:"Character,omitempty" db:"Character"`
	PreferenceValue int                   `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
}

func (t *Creator) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T Creator
	var overlay struct {
		*T
		PreferenceValue *int `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
	}
	overlay.T = (*T)(t)
	overlay.PreferenceValue = (*int)(&overlay.T.PreferenceValue)
	return d.DecodeElement(&overlay, &start)
}

type CreatorType struct {
	Role      ControlledTermUseType `xml:"urn:mpeg:mpeg7:schema:2001 Role" json:"Role" db:"Role"`
	Agent     *AgentType            `xml:"urn:mpeg:mpeg7:schema:2001 Agent,omitempty" json:"Agent,omitempty" db:"Agent"`
	AgentRef  *ReferenceType        `xml:"urn:mpeg:mpeg7:schema:2001 AgentRef,omitempty" json:"AgentRef,omitempty" db:"AgentRef"`
	Character []PersonNameType      `xml:"urn:mpeg:mpeg7:schema:2001 Character,omitempty" json:"Character,omitempty" db:"Character"`
}

type DASHComponentIdentifierType struct {
	PeriodIdentifier         string                 `xml:"periodIdentifier,attr" json:"periodIdentifier" db:"periodIdentifier"`
	AdaptationSetIdentifier  uint                   `xml:"adaptationSetIdentifier,attr" json:"adaptationSetIdentifier" db:"adaptationSetIdentifier"`
	RepresentationIdentifier StringNoWhitespaceType `xml:"representationIdentifier,attr" json:"representationIdentifier" db:"representationIdentifier"`
	ManifestIdRef            string                 `xml:"manifestIdRef,attr" json:"manifestIdRef" db:"manifestIdRef"`
}

type DSType struct {
	TimeBase string       `xml:"timeBase,attr,omitempty" json:"timeBase,omitempty" db:"timeBase"`
	TimeUnit DurationType `xml:"timeUnit,attr,omitempty" json:"timeUnit,omitempty" db:"timeUnit"`
}

type DType struct {
}

type DatePeriod struct {
	TimePoint        *TimePointType        `xml:"urn:mpeg:mpeg7:schema:2001 TimePoint,omitempty" json:"TimePoint,omitempty" db:"TimePoint"`
	RelTimePoint     *RelTimePointType     `xml:"urn:mpeg:mpeg7:schema:2001 RelTimePoint,omitempty" json:"RelTimePoint,omitempty" db:"RelTimePoint"`
	RelIncrTimePoint *RelIncrTimePointType `xml:"urn:mpeg:mpeg7:schema:2001 RelIncrTimePoint,omitempty" json:"RelIncrTimePoint,omitempty" db:"RelIncrTimePoint"`
	Duration         *DurationType         `xml:"urn:mpeg:mpeg7:schema:2001 Duration,omitempty" json:"Duration,omitempty" db:"Duration"`
	IncrDuration     *IncrDurationType     `xml:"urn:mpeg:mpeg7:schema:2001 IncrDuration,omitempty" json:"IncrDuration,omitempty" db:"IncrDuration"`
	PreferenceValue  int                   `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
}

func (t *DatePeriod) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T DatePeriod
	var overlay struct {
		*T
		PreferenceValue *int `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
	}
	overlay.T = (*T)(t)
	overlay.PreferenceValue = (*int)(&overlay.T.PreferenceValue)
	return d.DecodeElement(&overlay, &start)
}

type DisseminationDate struct {
	TimePoint        *TimePointType        `xml:"urn:mpeg:mpeg7:schema:2001 TimePoint,omitempty" json:"TimePoint,omitempty" db:"TimePoint"`
	RelTimePoint     *RelTimePointType     `xml:"urn:mpeg:mpeg7:schema:2001 RelTimePoint,omitempty" json:"RelTimePoint,omitempty" db:"RelTimePoint"`
	RelIncrTimePoint *RelIncrTimePointType `xml:"urn:mpeg:mpeg7:schema:2001 RelIncrTimePoint,omitempty" json:"RelIncrTimePoint,omitempty" db:"RelIncrTimePoint"`
	Duration         *DurationType         `xml:"urn:mpeg:mpeg7:schema:2001 Duration,omitempty" json:"Duration,omitempty" db:"Duration"`
	IncrDuration     *IncrDurationType     `xml:"urn:mpeg:mpeg7:schema:2001 IncrDuration,omitempty" json:"IncrDuration,omitempty" db:"IncrDuration"`
	PreferenceValue  int                   `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
}

func (t *DisseminationDate) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T DisseminationDate
	var overlay struct {
		*T
		PreferenceValue *int `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
	}
	overlay.T = (*T)(t)
	overlay.PreferenceValue = (*int)(&overlay.T.PreferenceValue)
	return d.DecodeElement(&overlay, &start)
}

type DisseminationFormat struct {
	Name            []Name        `xml:"urn:mpeg:mpeg7:schema:2001 Name,omitempty" json:"Name,omitempty" db:"Name"`
	Definition      []TextualType `xml:"urn:mpeg:mpeg7:schema:2001 Definition,omitempty" json:"Definition,omitempty" db:"Definition"`
	PreferenceValue int           `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
}

func (t *DisseminationFormat) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T DisseminationFormat
	var overlay struct {
		*T
		PreferenceValue *int `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
	}
	overlay.T = (*T)(t)
	overlay.PreferenceValue = (*int)(&overlay.T.PreferenceValue)
	return d.DecodeElement(&overlay, &start)
}

type DisseminationLocation struct {
	Name                []TextualType           `xml:"urn:mpeg:mpeg7:schema:2001 Name,omitempty" json:"Name,omitempty" db:"Name"`
	NameTerm            []ControlledTermUseType `xml:"urn:mpeg:mpeg7:schema:2001 NameTerm,omitempty" json:"NameTerm,omitempty" db:"NameTerm"`
	Role                *TermUseType            `xml:"urn:mpeg:mpeg7:schema:2001 Role,omitempty" json:"Role,omitempty" db:"Role"`
	GeographicPosition  *GeographicPosition     `xml:"urn:mpeg:mpeg7:schema:2001 GeographicPosition,omitempty" json:"GeographicPosition,omitempty" db:"GeographicPosition"`
	Region              []RegionCode            `xml:"urn:mpeg:mpeg7:schema:2001 Region,omitempty" json:"Region,omitempty" db:"Region"`
	AdministrativeUnit  []AdministrativeUnit    `xml:"urn:mpeg:mpeg7:schema:2001 AdministrativeUnit,omitempty" json:"AdministrativeUnit,omitempty" db:"AdministrativeUnit"`
	PostalAddress       *PostalAddress          `xml:"urn:mpeg:mpeg7:schema:2001 PostalAddress,omitempty" json:"PostalAddress,omitempty" db:"PostalAddress"`
	InternalCoordinates *string                 `xml:"urn:mpeg:mpeg7:schema:2001 InternalCoordinates,omitempty" json:"InternalCoordinates,omitempty" db:"InternalCoordinates"`
	PreferenceValue     int                     `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
	Lang                Lang                    `xml:"http://www.w3.org/XML/1998/namespace lang,attr,omitempty" json:"lang,omitempty" db:"lang"`
	TimeBase            string                  `xml:"timeBase,attr,omitempty" json:"timeBase,omitempty" db:"timeBase"`
	TimeUnit            DurationType            `xml:"timeUnit,attr,omitempty" json:"timeUnit,omitempty" db:"timeUnit"`
}

func (t *DisseminationLocation) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T DisseminationLocation
	var overlay struct {
		*T
		PreferenceValue *int `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
	}
	overlay.T = (*T)(t)
	overlay.PreferenceValue = (*int)(&overlay.T.PreferenceValue)
	return d.DecodeElement(&overlay, &start)
}

type DisseminationSource struct {
	Value           string `xml:",chardata"`
	PreferenceValue int    `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
	Lang            Lang   `xml:"http://www.w3.org/XML/1998/namespace lang,attr,omitempty" json:"lang,omitempty" db:"lang"`
}

func (t *DisseminationSource) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T DisseminationSource
	var overlay struct {
		*T
		PreferenceValue *int `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
	}
	overlay.T = (*T)(t)
	overlay.PreferenceValue = (*int)(&overlay.T.PreferenceValue)
	return d.DecodeElement(&overlay, &start)
}

type Disseminator struct {
	Role            ControlledTermUseType `xml:"urn:mpeg:mpeg7:schema:2001 Role" json:"Role" db:"Role"`
	Agent           *AgentType            `xml:"urn:mpeg:mpeg7:schema:2001 Agent,omitempty" json:"Agent,omitempty" db:"Agent"`
	AgentRef        *ReferenceType        `xml:"urn:mpeg:mpeg7:schema:2001 AgentRef,omitempty" json:"AgentRef,omitempty" db:"AgentRef"`
	PreferenceValue int                   `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
}

func (t *Disseminator) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T Disseminator
	var overlay struct {
		*T
		PreferenceValue *int `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
	}
	overlay.T = (*T)(t)
	overlay.PreferenceValue = (*int)(&overlay.T.PreferenceValue)
	return d.DecodeElement(&overlay, &start)
}

type Domain []string

func (x *Domain) MarshalText() ([]byte, error) {
	result := make([][]byte, 0, len(*x))
	for _, v := range *x {
		result = append(result, []byte(v))
	}
	return bytes.Join(result, []byte(" ")), nil
}
func (x *Domain) UnmarshalText(text []byte) error {
	for _, v := range bytes.Fields(text) {
		*x = append(*x, string(v))
	}
	return nil
}

// Must match the pattern \-?P(\d+D)?(T(\d+H)?(\d+M)?(\d+S)?(\d+N)?)?(\d+F)?((\-|\+)\d{2}:\d{2}Z)?
type DurationType string

type ElectronicAddressType struct {
	Telephone []Telephone `xml:"urn:mpeg:mpeg7:schema:2001 Telephone,omitempty" json:"Telephone,omitempty" db:"Telephone"`
	Fax       []string    `xml:"urn:mpeg:mpeg7:schema:2001 Fax,omitempty" json:"Fax,omitempty" db:"Fax"`
	Email     []string    `xml:"urn:mpeg:mpeg7:schema:2001 Email,omitempty" json:"Email,omitempty" db:"Email"`
	Url       []string    `xml:"urn:mpeg:mpeg7:schema:2001 Url,omitempty" json:"Url,omitempty" db:"Url"`
}

type Emphasis string

// May be one of text, base16, base64
type Encoding string

type ExtendedLanguageType struct {
	Value        string `xml:",chardata"`
	Type         Type   `xml:"type,attr,omitempty" json:"type,omitempty" db:"type"`
	Supplemental bool   `xml:"supplemental,attr,omitempty" json:"supplemental,omitempty" db:"supplemental"`
}

func (t *ExtendedLanguageType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T ExtendedLanguageType
	var overlay struct {
		*T
		Type         *Type `xml:"type,attr,omitempty" json:"type,omitempty" db:"type"`
		Supplemental *bool `xml:"supplemental,attr,omitempty" json:"supplemental,omitempty" db:"supplemental"`
	}
	overlay.T = (*T)(t)
	overlay.Type = (*Type)(&overlay.T.Type)
	overlay.Supplemental = (*bool)(&overlay.T.Supplemental)
	return d.DecodeElement(&overlay, &start)
}

type FilteringAndSearchPreferencesType struct {
	CreationPreferences           []CreationPreferencesType           `xml:"urn:mpeg:mpeg7:schema:2001 CreationPreferences,omitempty" json:"CreationPreferences,omitempty" db:"CreationPreferences"`
	ClassificationPreferences     []ClassificationPreferencesType     `xml:"urn:mpeg:mpeg7:schema:2001 ClassificationPreferences,omitempty" json:"ClassificationPreferences,omitempty" db:"ClassificationPreferences"`
	SourcePreferences             []SourcePreferencesType             `xml:"urn:mpeg:mpeg7:schema:2001 SourcePreferences,omitempty" json:"SourcePreferences,omitempty" db:"SourcePreferences"`
	PreferenceCondition           []PreferenceConditionType           `xml:"urn:mpeg:mpeg7:schema:2001 PreferenceCondition,omitempty" json:"PreferenceCondition,omitempty" db:"PreferenceCondition"`
	FilteringAndSearchPreferences []FilteringAndSearchPreferencesType `xml:"urn:mpeg:mpeg7:schema:2001 FilteringAndSearchPreferences,omitempty" json:"FilteringAndSearchPreferences,omitempty" db:"FilteringAndSearchPreferences"`
	Protected                     UserChoiceType                      `xml:"protected,attr,omitempty" json:"protected,omitempty" db:"protected"`
	PreferenceValue               int                                 `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
	TimeBase                      string                              `xml:"timeBase,attr,omitempty" json:"timeBase,omitempty" db:"timeBase"`
	TimeUnit                      DurationType                        `xml:"timeUnit,attr,omitempty" json:"timeUnit,omitempty" db:"timeUnit"`
}

func (t *FilteringAndSearchPreferencesType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T FilteringAndSearchPreferencesType
	var overlay struct {
		*T
		Protected       *UserChoiceType `xml:"protected,attr,omitempty" json:"protected,omitempty" db:"protected"`
		PreferenceValue *int            `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
	}
	overlay.T = (*T)(t)
	overlay.Protected = (*UserChoiceType)(&overlay.T.Protected)
	overlay.PreferenceValue = (*int)(&overlay.T.PreferenceValue)
	return d.DecodeElement(&overlay, &start)
}

type FloatVector []float64

func (x *FloatVector) MarshalText() ([]byte, error) {
	result := make([][]byte, 0, len(*x))
	for _, v := range *x {
		s := strconv.FormatFloat(v, 'g', -1, 64)
		result = append(result, []byte(s))
	}
	return bytes.Join(result, []byte(" ")), nil
}
func (x *FloatVector) UnmarshalText(text []byte) error {
	for _, v := range strings.Fields(string(text)) {
		if f, err := strconv.ParseFloat(v, 64); err != nil {
			return err
		} else {
			*x = append(*x, f)
		}
	}
	return nil
}

type Form struct {
	Name            []Name        `xml:"urn:mpeg:mpeg7:schema:2001 Name,omitempty" json:"Name,omitempty" db:"Name"`
	Definition      []TextualType `xml:"urn:mpeg:mpeg7:schema:2001 Definition,omitempty" json:"Definition,omitempty" db:"Definition"`
	PreferenceValue int           `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
}

func (t *Form) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T Form
	var overlay struct {
		*T
		PreferenceValue *int `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
	}
	overlay.T = (*T)(t)
	overlay.PreferenceValue = (*int)(&overlay.T.PreferenceValue)
	return d.DecodeElement(&overlay, &start)
}

type Format struct {
	Name        []Name        `xml:"urn:mpeg:mpeg7:schema:2001 Name,omitempty" json:"Name,omitempty" db:"Name"`
	Definition  []TextualType `xml:"urn:mpeg:mpeg7:schema:2001 Definition,omitempty" json:"Definition,omitempty" db:"Definition"`
	ColorDomain ColorDomain   `xml:"colorDomain,attr,omitempty" json:"colorDomain,omitempty" db:"colorDomain"`
}

func (t *Format) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T Format
	var overlay struct {
		*T
		ColorDomain *ColorDomain `xml:"colorDomain,attr,omitempty" json:"colorDomain,omitempty" db:"colorDomain"`
	}
	overlay.T = (*T)(t)
	overlay.ColorDomain = (*ColorDomain)(&overlay.T.ColorDomain)
	return d.DecodeElement(&overlay, &start)
}

// A set of parameters describing an Application Level Forward Error Correction
// configuration.
type ForwardErrorCorrectionParametersType struct {
	SchemeIdentifier   TermReferenceType              `xml:"urn:dvb:metadata:MulticastSessionConfiguration:2019 SchemeIdentifier" json:"SchemeIdentifier" db:"SchemeIdentifier"`
	OverheadPercentage int                            `xml:"urn:dvb:metadata:MulticastSessionConfiguration:2019 OverheadPercentage" json:"OverheadPercentage" db:"OverheadPercentage"`
	EndpointAddress    []MulticastEndpointAddressType `xml:"urn:dvb:metadata:MulticastSessionConfiguration:2019 EndpointAddress,omitempty" json:"EndpointAddress,omitempty" db:"EndpointAddress"`
}

type Frame struct {
	Height      int       `xml:"height,attr,omitempty" json:"height,omitempty" db:"height"`
	Width       int       `xml:"width,attr,omitempty" json:"width,omitempty" db:"width"`
	AspectRatio float64   `xml:"aspectRatio,attr,omitempty" json:"aspectRatio,omitempty" db:"aspectRatio"`
	Rate        float64   `xml:"rate,attr,omitempty" json:"rate,omitempty" db:"rate"`
	Structure   Structure `xml:"structure,attr,omitempty" json:"structure,omitempty" db:"structure"`
}

type GenericComponentIdentifierType struct {
	ComponentIdentifier string `xml:"componentIdentifier,attr" json:"componentIdentifier" db:"componentIdentifier"`
	ManifestIdRef       string `xml:"manifestIdRef,attr" json:"manifestIdRef" db:"manifestIdRef"`
}

type Genre struct {
	Name            []Name        `xml:"urn:mpeg:mpeg7:schema:2001 Name,omitempty" json:"Name,omitempty" db:"Name"`
	Definition      []TextualType `xml:"urn:mpeg:mpeg7:schema:2001 Definition,omitempty" json:"Definition,omitempty" db:"Definition"`
	PreferenceValue int           `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
}

func (t *Genre) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T Genre
	var overlay struct {
		*T
		PreferenceValue *int `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
	}
	overlay.T = (*T)(t)
	overlay.PreferenceValue = (*int)(&overlay.T.PreferenceValue)
	return d.DecodeElement(&overlay, &start)
}

type GeographicPointType struct {
	Longitude float64 `xml:"longitude,attr" json:"longitude" db:"longitude"`
	Latitude  float64 `xml:"latitude,attr" json:"latitude" db:"latitude"`
	Altitude  float64 `xml:"altitude,attr,omitempty" json:"altitude,omitempty" db:"altitude"`
}

type GeographicPosition struct {
	Point GeographicPointType `xml:"urn:mpeg:mpeg7:schema:2001 Point" json:"Point" db:"Point"`
	Datum string              `xml:"datum,attr,omitempty" json:"datum,omitempty" db:"datum"`
}

type HLSComponentIdentifierType struct {
	MediaPlaylistLocator string `xml:"mediaPlaylistLocator,attr" json:"mediaPlaylistLocator" db:"mediaPlaylistLocator"`
	ManifestIdRef        string `xml:"manifestIdRef,attr" json:"manifestIdRef" db:"manifestIdRef"`
}

type HeaderType struct {
}

type ImageLocatorType struct {
	MediaUri       *string             `xml:"urn:mpeg:mpeg7:schema:2001 MediaUri,omitempty" json:"MediaUri,omitempty" db:"MediaUri"`
	InlineMedia    *InlineMediaType    `xml:"urn:mpeg:mpeg7:schema:2001 InlineMedia,omitempty" json:"InlineMedia,omitempty" db:"InlineMedia"`
	StreamID       *int                `xml:"urn:mpeg:mpeg7:schema:2001 StreamID,omitempty" json:"StreamID,omitempty" db:"StreamID"`
	MediaTimePoint *MediaTimePointType `xml:"urn:mpeg:mpeg7:schema:2001 MediaTimePoint,omitempty" json:"MediaTimePoint,omitempty" db:"MediaTimePoint"`
	BytePosition   *BytePosition       `xml:"urn:mpeg:mpeg7:schema:2001 BytePosition,omitempty" json:"BytePosition,omitempty" db:"BytePosition"`
}

type IncrDurationType struct {
	Value    int          `xml:",chardata"`
	TimeUnit DurationType `xml:"timeUnit,attr,omitempty" json:"timeUnit,omitempty" db:"timeUnit"`
}

type InlineMediaType struct {
	MediaData16 *[]byte  `xml:"urn:mpeg:mpeg7:schema:2001 MediaData16,omitempty" json:"MediaData16,omitempty" db:"MediaData16"`
	MediaData64 *[]byte  `xml:"urn:mpeg:mpeg7:schema:2001 MediaData64,omitempty" json:"MediaData64,omitempty" db:"MediaData64"`
	Type        MimeType `xml:"type,attr" json:"type" db:"type"`
}

func (t *InlineMediaType) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	type T InlineMediaType
	var layout struct {
		*T
		MediaData16 *xsdHexBinary    `xml:"urn:mpeg:mpeg7:schema:2001 MediaData16,omitempty" json:"MediaData16,omitempty" db:"MediaData16"`
		MediaData64 *xsdBase64Binary `xml:"urn:mpeg:mpeg7:schema:2001 MediaData64,omitempty" json:"MediaData64,omitempty" db:"MediaData64"`
	}
	layout.T = (*T)(t)
	layout.MediaData16 = (*xsdHexBinary)(layout.T.MediaData16)
	layout.MediaData64 = (*xsdBase64Binary)(layout.T.MediaData64)
	return e.EncodeElement(layout, start)
}
func (t *InlineMediaType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T InlineMediaType
	var overlay struct {
		*T
		MediaData16 *xsdHexBinary    `xml:"urn:mpeg:mpeg7:schema:2001 MediaData16,omitempty" json:"MediaData16,omitempty" db:"MediaData16"`
		MediaData64 *xsdBase64Binary `xml:"urn:mpeg:mpeg7:schema:2001 MediaData64,omitempty" json:"MediaData64,omitempty" db:"MediaData64"`
	}
	overlay.T = (*T)(t)
	overlay.MediaData16 = (*xsdHexBinary)(overlay.T.MediaData16)
	overlay.MediaData64 = (*xsdBase64Binary)(overlay.T.MediaData64)
	return d.DecodeElement(&overlay, &start)
}

type InlineTermDefinitionType struct {
	Name       []Name        `xml:"urn:mpeg:mpeg7:schema:2001 Name,omitempty" json:"Name,omitempty" db:"Name"`
	Definition []TextualType `xml:"urn:mpeg:mpeg7:schema:2001 Definition,omitempty" json:"Definition,omitempty" db:"Definition"`
}

type Keyword struct {
	Value           string `xml:",chardata"`
	PreferenceValue int    `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
	Lang            Lang   `xml:"http://www.w3.org/XML/1998/namespace lang,attr,omitempty" json:"lang,omitempty" db:"lang"`
}

func (t *Keyword) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T Keyword
	var overlay struct {
		*T
		PreferenceValue *int `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
	}
	overlay.T = (*T)(t)
	overlay.PreferenceValue = (*int)(&overlay.T.PreferenceValue)
	return d.DecodeElement(&overlay, &start)
}

type Lang string

type Language struct {
	Value           string `xml:",chardata"`
	PreferenceValue int    `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
	Type            Type   `xml:"type,attr,omitempty" json:"type,omitempty" db:"type"`
	Supplemental    bool   `xml:"supplemental,attr,omitempty" json:"supplemental,omitempty" db:"supplemental"`
}

func (t *Language) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T Language
	var overlay struct {
		*T
		PreferenceValue *int  `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
		Type            *Type `xml:"type,attr,omitempty" json:"type,omitempty" db:"type"`
		Supplemental    *bool `xml:"supplemental,attr,omitempty" json:"supplemental,omitempty" db:"supplemental"`
	}
	overlay.T = (*T)(t)
	overlay.PreferenceValue = (*int)(&overlay.T.PreferenceValue)
	overlay.Type = (*Type)(&overlay.T.Type)
	overlay.Supplemental = (*bool)(&overlay.T.Supplemental)
	return d.DecodeElement(&overlay, &start)
}

type LanguageFormat struct {
	AuxiliaryLanguageType AuxiliaryLanguageType `xml:",chardata"`
	PreferenceValue       int                   `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
}

func (t *LanguageFormat) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T LanguageFormat
	var overlay struct {
		*T
		PreferenceValue *int `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
	}
	overlay.T = (*T)(t)
	overlay.PreferenceValue = (*int)(&overlay.T.PreferenceValue)
	return d.DecodeElement(&overlay, &start)
}

type Location struct {
	Name                []TextualType           `xml:"urn:mpeg:mpeg7:schema:2001 Name,omitempty" json:"Name,omitempty" db:"Name"`
	NameTerm            []ControlledTermUseType `xml:"urn:mpeg:mpeg7:schema:2001 NameTerm,omitempty" json:"NameTerm,omitempty" db:"NameTerm"`
	Role                *TermUseType            `xml:"urn:mpeg:mpeg7:schema:2001 Role,omitempty" json:"Role,omitempty" db:"Role"`
	GeographicPosition  *GeographicPosition     `xml:"urn:mpeg:mpeg7:schema:2001 GeographicPosition,omitempty" json:"GeographicPosition,omitempty" db:"GeographicPosition"`
	Region              []RegionCode            `xml:"urn:mpeg:mpeg7:schema:2001 Region,omitempty" json:"Region,omitempty" db:"Region"`
	AdministrativeUnit  []AdministrativeUnit    `xml:"urn:mpeg:mpeg7:schema:2001 AdministrativeUnit,omitempty" json:"AdministrativeUnit,omitempty" db:"AdministrativeUnit"`
	PostalAddress       *PostalAddress          `xml:"urn:mpeg:mpeg7:schema:2001 PostalAddress,omitempty" json:"PostalAddress,omitempty" db:"PostalAddress"`
	InternalCoordinates *string                 `xml:"urn:mpeg:mpeg7:schema:2001 InternalCoordinates,omitempty" json:"InternalCoordinates,omitempty" db:"InternalCoordinates"`
	PreferenceValue     int                     `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
	Lang                Lang                    `xml:"http://www.w3.org/XML/1998/namespace lang,attr,omitempty" json:"lang,omitempty" db:"lang"`
	TimeBase            string                  `xml:"timeBase,attr,omitempty" json:"timeBase,omitempty" db:"timeBase"`
	TimeUnit            DurationType            `xml:"timeUnit,attr,omitempty" json:"timeUnit,omitempty" db:"timeUnit"`
}

func (t *Location) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T Location
	var overlay struct {
		*T
		PreferenceValue *int `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
	}
	overlay.T = (*T)(t)
	overlay.PreferenceValue = (*int)(&overlay.T.PreferenceValue)
	return d.DecodeElement(&overlay, &start)
}

type MediaAgentType struct {
	Role     ControlledTermUseType `xml:"urn:mpeg:mpeg7:schema:2001 Role" json:"Role" db:"Role"`
	Agent    *AgentType            `xml:"urn:mpeg:mpeg7:schema:2001 Agent,omitempty" json:"Agent,omitempty" db:"Agent"`
	AgentRef *ReferenceType        `xml:"urn:mpeg:mpeg7:schema:2001 AgentRef,omitempty" json:"AgentRef,omitempty" db:"AgentRef"`
}

// Must match the pattern \-?P(\d+D)?(T(\d+H)?(\d+M)?(\d+S)?(\d+N)?)?(\d+F)?
type MediaDurationType string

type MediaFormat struct {
	Content              ControlledTermUseType  `xml:"urn:mpeg:mpeg7:schema:2001 Content" json:"Content" db:"Content"`
	Medium               *ControlledTermUseType `xml:"urn:mpeg:mpeg7:schema:2001 Medium,omitempty" json:"Medium,omitempty" db:"Medium"`
	FileFormat           *ControlledTermUseType `xml:"urn:mpeg:mpeg7:schema:2001 FileFormat,omitempty" json:"FileFormat,omitempty" db:"FileFormat"`
	FileSize             *int                   `xml:"urn:mpeg:mpeg7:schema:2001 FileSize,omitempty" json:"FileSize,omitempty" db:"FileSize"`
	System               *ControlledTermUseType `xml:"urn:mpeg:mpeg7:schema:2001 System,omitempty" json:"System,omitempty" db:"System"`
	BitRate              *BitRate               `xml:"urn:mpeg:mpeg7:schema:2001 BitRate,omitempty" json:"BitRate,omitempty" db:"BitRate"`
	VisualCoding         *VisualCoding          `xml:"urn:mpeg:mpeg7:schema:2001 VisualCoding,omitempty" json:"VisualCoding,omitempty" db:"VisualCoding"`
	AudioCoding          *AudioCoding           `xml:"urn:mpeg:mpeg7:schema:2001 AudioCoding,omitempty" json:"AudioCoding,omitempty" db:"AudioCoding"`
	SceneCodingFormat    *ControlledTermUseType `xml:"urn:mpeg:mpeg7:schema:2001 SceneCodingFormat,omitempty" json:"SceneCodingFormat,omitempty" db:"SceneCodingFormat"`
	GraphicsCodingFormat *ControlledTermUseType `xml:"urn:mpeg:mpeg7:schema:2001 GraphicsCodingFormat,omitempty" json:"GraphicsCodingFormat,omitempty" db:"GraphicsCodingFormat"`
	OtherCodingFormat    *ControlledTermUseType `xml:"urn:mpeg:mpeg7:schema:2001 OtherCodingFormat,omitempty" json:"OtherCodingFormat,omitempty" db:"OtherCodingFormat"`
	PreferenceValue      int                    `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
}

func (t *MediaFormat) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T MediaFormat
	var overlay struct {
		*T
		PreferenceValue *int `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
	}
	overlay.T = (*T)(t)
	overlay.PreferenceValue = (*int)(&overlay.T.PreferenceValue)
	return d.DecodeElement(&overlay, &start)
}

type MediaFormatType struct {
	Content              ControlledTermUseType  `xml:"urn:mpeg:mpeg7:schema:2001 Content" json:"Content" db:"Content"`
	Medium               *ControlledTermUseType `xml:"urn:mpeg:mpeg7:schema:2001 Medium,omitempty" json:"Medium,omitempty" db:"Medium"`
	FileFormat           *ControlledTermUseType `xml:"urn:mpeg:mpeg7:schema:2001 FileFormat,omitempty" json:"FileFormat,omitempty" db:"FileFormat"`
	FileSize             *int                   `xml:"urn:mpeg:mpeg7:schema:2001 FileSize,omitempty" json:"FileSize,omitempty" db:"FileSize"`
	System               *ControlledTermUseType `xml:"urn:mpeg:mpeg7:schema:2001 System,omitempty" json:"System,omitempty" db:"System"`
	BitRate              *BitRate               `xml:"urn:mpeg:mpeg7:schema:2001 BitRate,omitempty" json:"BitRate,omitempty" db:"BitRate"`
	VisualCoding         *VisualCoding          `xml:"urn:mpeg:mpeg7:schema:2001 VisualCoding,omitempty" json:"VisualCoding,omitempty" db:"VisualCoding"`
	AudioCoding          *AudioCoding           `xml:"urn:mpeg:mpeg7:schema:2001 AudioCoding,omitempty" json:"AudioCoding,omitempty" db:"AudioCoding"`
	SceneCodingFormat    *ControlledTermUseType `xml:"urn:mpeg:mpeg7:schema:2001 SceneCodingFormat,omitempty" json:"SceneCodingFormat,omitempty" db:"SceneCodingFormat"`
	GraphicsCodingFormat *ControlledTermUseType `xml:"urn:mpeg:mpeg7:schema:2001 GraphicsCodingFormat,omitempty" json:"GraphicsCodingFormat,omitempty" db:"GraphicsCodingFormat"`
	OtherCodingFormat    *ControlledTermUseType `xml:"urn:mpeg:mpeg7:schema:2001 OtherCodingFormat,omitempty" json:"OtherCodingFormat,omitempty" db:"OtherCodingFormat"`
}

type MediaIncrDurationType struct {
	Value         int               `xml:",chardata"`
	MediaTimeUnit MediaDurationType `xml:"mediaTimeUnit,attr,omitempty" json:"mediaTimeUnit,omitempty" db:"mediaTimeUnit"`
}

type MediaLocatorType struct {
	MediaUri    *string          `xml:"urn:mpeg:mpeg7:schema:2001 MediaUri,omitempty" json:"MediaUri,omitempty" db:"MediaUri"`
	InlineMedia *InlineMediaType `xml:"urn:mpeg:mpeg7:schema:2001 InlineMedia,omitempty" json:"InlineMedia,omitempty" db:"InlineMedia"`
	StreamID    *int             `xml:"urn:mpeg:mpeg7:schema:2001 StreamID,omitempty" json:"StreamID,omitempty" db:"StreamID"`
}

type MediaRelIncrTimePointType struct {
	Value         int               `xml:",chardata"`
	MediaTimeUnit MediaDurationType `xml:"mediaTimeUnit,attr,omitempty" json:"mediaTimeUnit,omitempty" db:"mediaTimeUnit"`
}

// Must match the pattern \-?P(\d+D)?(T(\d+H)?(\d+M)?(\d+S)?(\d+N)?)?(\d+F)?
type MediaTimeOffsetType string

// Must match the pattern (\-?\d+(\-\d{2}(\-\d{2})?)?)?(T\d{2}(:\d{2}(:\d{2}(:\d+)?)?)?)?(F\d+)?
type MediaTimePointType string

type MediaTimeType struct {
	MediaTimePoint    *MediaTimePointType    `xml:"urn:mpeg:mpeg7:schema:2001 MediaTimePoint,omitempty" json:"MediaTimePoint,omitempty" db:"MediaTimePoint"`
	MediaDuration     *MediaDurationType     `xml:"urn:mpeg:mpeg7:schema:2001 MediaDuration,omitempty" json:"MediaDuration,omitempty" db:"MediaDuration"`
	MediaIncrDuration *MediaIncrDurationType `xml:"urn:mpeg:mpeg7:schema:2001 MediaIncrDuration,omitempty" json:"MediaIncrDuration,omitempty" db:"MediaIncrDuration"`
}

// Must match the pattern [!--[\(\)<>@,;:\\"/\[\]\?=]]+/[!--[\(\)<>@,;:\\"/\[\]\?=]]+
type MimeType string

func (m *MimeType) Scan(src interface{}) error {
	if src == nil {
		*m = ""
		return nil
	}
	switch v := src.(type) {
	case string:
		*m = MimeType(v)
	case []byte:
		*m = MimeType(string(v))
	default:
		return fmt.Errorf("cannot scan %T into MimeType", src)
	}
	return nil
}

func (m MimeType) Value() (driver.Value, error) {
	return string(m), nil
}

type Mpeg7BaseType struct {
}

type MulticastEndpointAddressType struct {
	NetworkSourceAddress           string `xml:"urn:dvb:metadata:MulticastSessionConfiguration:2019 NetworkSourceAddress" json:"NetworkSourceAddress" db:"NetworkSourceAddress"`
	NetworkDestinationGroupAddress string `xml:"urn:dvb:metadata:MulticastSessionConfiguration:2019 NetworkDestinationGroupAddress" json:"NetworkDestinationGroupAddress" db:"NetworkDestinationGroupAddress"`
	TransportDestinationPort       int    `xml:"urn:dvb:metadata:MulticastSessionConfiguration:2019 TransportDestinationPort" json:"TransportDestinationPort" db:"TransportDestinationPort"`
	MediaTransportSessionIdentfier *int   `xml:"urn:dvb:metadata:MulticastSessionConfiguration:2019 MediaTransportSessionIdentfier,omitempty" json:"MediaTransportSessionIdentfier,omitempty" db:"MediaTransportSessionIdentfier"`
}

type MulticastGatewayConfiguration struct {
	MulticastGatewayConfigurationTransportSession []BaseMulticastTransportSessionType `xml:"urn:dvb:metadata:MulticastSessionConfiguration:2019 MulticastGatewayConfigurationTransportSession,omitempty" json:"MulticastGatewayConfigurationTransportSession,omitempty" db:"MulticastGatewayConfigurationTransportSession"`
	MulticastSession                              []MulticastSessionType              `xml:"urn:dvb:metadata:MulticastSessionConfiguration:2019 MulticastSession,omitempty" json:"MulticastSession,omitempty" db:"MulticastSession"`
	ValidityPeriod                                string                              `xml:"validityPeriod,attr,omitempty" json:"validityPeriod,omitempty" db:"validityPeriod"`
	ValidUntil                                    TimePointType                       `xml:"validUntil,attr,omitempty" json:"validUntil,omitempty" db:"validUntil"`
}

type MulticastServerConfiguration struct {
	MulticastGatewayConfigurationTransportSession []BaseMulticastTransportSessionType `xml:"urn:dvb:metadata:MulticastSessionConfiguration:2019 MulticastGatewayConfigurationTransportSession,omitempty" json:"MulticastGatewayConfigurationTransportSession,omitempty" db:"MulticastGatewayConfigurationTransportSession"`
	MulticastSession                              []MulticastSessionType              `xml:"urn:dvb:metadata:MulticastSessionConfiguration:2019 MulticastSession,omitempty" json:"MulticastSession,omitempty" db:"MulticastSession"`
	ValidityPeriod                                string                              `xml:"validityPeriod,attr,omitempty" json:"validityPeriod,omitempty" db:"validityPeriod"`
	ValidUntil                                    TimePointType                       `xml:"validUntil,attr,omitempty" json:"validUntil,omitempty" db:"validUntil"`
}

// All the multicast transport sessions required to deliver a single linear service
// according to operational needs.
type MulticastSessionType struct {
	PresentationManifestLocator       []PresentationManifestLocator   `xml:"urn:dvb:metadata:MulticastSessionConfiguration:2019 PresentationManifestLocator" json:"PresentationManifestLocator" db:"PresentationManifestLocator"`
	MulticastGatewaySessionReporting  *SessionReportingType           `xml:"urn:dvb:metadata:MulticastSessionConfiguration:2019 MulticastGatewaySessionReporting,omitempty" json:"MulticastGatewaySessionReporting,omitempty" db:"MulticastGatewaySessionReporting"`
	MulticastTransportSession         []MulticastTransportSessionType `xml:"urn:dvb:metadata:MulticastSessionConfiguration:2019 MulticastTransportSession" json:"MulticastTransportSession" db:"MulticastTransportSession"`
	ServiceIdentifier                 string                          `xml:"serviceIdentifier,attr" json:"serviceIdentifier" db:"serviceIdentifier"`
	ContentPlaybackAvailabilityOffset string                          `xml:"contentPlaybackAvailabilityOffset,attr,omitempty" json:"contentPlaybackAvailabilityOffset,omitempty" db:"contentPlaybackAvailabilityOffset"`
}

func (t *MulticastSessionType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T MulticastSessionType
	var overlay struct {
		*T
		ContentPlaybackAvailabilityOffset *string `xml:"contentPlaybackAvailabilityOffset,attr,omitempty" json:"contentPlaybackAvailabilityOffset,omitempty" db:"contentPlaybackAvailabilityOffset"`
	}
	overlay.T = (*T)(t)
	overlay.ContentPlaybackAvailabilityOffset = (*string)(&overlay.T.ContentPlaybackAvailabilityOffset)
	return d.DecodeElement(&overlay, &start)
}

type MulticastTransportProtocolType struct {
	ProtocolIdentifier TermReferenceType `xml:"protocolIdentifier,attr" json:"protocolIdentifier" db:"protocolIdentifier"`
	ProtocolVersion    int               `xml:"protocolVersion,attr" json:"protocolVersion" db:"protocolVersion"`
}

type MulticastTransportSessionType struct {
	TransportProtocol                MulticastTransportProtocolType         `xml:"urn:dvb:metadata:MulticastSessionConfiguration:2019 TransportProtocol" json:"TransportProtocol" db:"TransportProtocol"`
	EndpointAddress                  []MulticastEndpointAddressType         `xml:"urn:dvb:metadata:MulticastSessionConfiguration:2019 EndpointAddress" json:"EndpointAddress" db:"EndpointAddress"`
	BitRate                          BitRateType                            `xml:"urn:dvb:metadata:MulticastSessionConfiguration:2019 BitRate" json:"BitRate" db:"BitRate"`
	ForwardErrorCorrectionParameters []ForwardErrorCorrectionParametersType `xml:"urn:dvb:metadata:MulticastSessionConfiguration:2019 ForwardErrorCorrectionParameters,omitempty" json:"ForwardErrorCorrectionParameters,omitempty" db:"ForwardErrorCorrectionParameters"`
	UnicastRepairParameters          *UnicastRepairParametersType           `xml:"urn:dvb:metadata:MulticastSessionConfiguration:2019 UnicastRepairParameters,omitempty" json:"UnicastRepairParameters,omitempty" db:"UnicastRepairParameters"`
	ServiceComponentIdentifier       []ServiceComponentIdentifierType       `xml:"urn:dvb:metadata:MulticastSessionConfiguration:2019 ServiceComponentIdentifier" json:"ServiceComponentIdentifier" db:"ServiceComponentIdentifier"`
	Start                            TimePointType                          `xml:"start,attr,omitempty" json:"start,omitempty" db:"start"`
	Duration                         string                                 `xml:"duration,attr,omitempty" json:"duration,omitempty" db:"duration"`
	ContentIngestMethod              ContentAcquisitionMethodType           `xml:"contentIngestMethod,attr,omitempty" json:"contentIngestMethod,omitempty" db:"contentIngestMethod"`
	TransmissionMode                 TransmissionModeType                   `xml:"transmissionMode,attr,omitempty" json:"transmissionMode,omitempty" db:"transmissionMode"`
	SessionIdleTimeout               int                                    `xml:"sessionIdleTimeout,attr" json:"sessionIdleTimeout" db:"sessionIdleTimeout"`
	TransportSecurity                TransportSecurityType                  `xml:"transportSecurity,attr,omitempty" json:"transportSecurity,omitempty" db:"transportSecurity"`
}

func (t *MulticastTransportSessionType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T MulticastTransportSessionType
	var overlay struct {
		*T
		ContentIngestMethod *ContentAcquisitionMethodType `xml:"contentIngestMethod,attr,omitempty" json:"contentIngestMethod,omitempty" db:"contentIngestMethod"`
		TransmissionMode    *TransmissionModeType         `xml:"transmissionMode,attr,omitempty" json:"transmissionMode,omitempty" db:"transmissionMode"`
		TransportSecurity   *TransportSecurityType        `xml:"transportSecurity,attr,omitempty" json:"transportSecurity,omitempty" db:"transportSecurity"`
	}
	overlay.T = (*T)(t)
	overlay.ContentIngestMethod = (*ContentAcquisitionMethodType)(&overlay.T.ContentIngestMethod)
	overlay.TransmissionMode = (*TransmissionModeType)(&overlay.T.TransmissionMode)
	overlay.TransportSecurity = (*TransportSecurityType)(&overlay.T.TransportSecurity)
	return d.DecodeElement(&overlay, &start)
}

type Name struct {
	Value     string `xml:",chardata"`
	Preferred bool   `xml:"preferred,attr,omitempty" json:"preferred,omitempty" db:"preferred"`
	Lang      Lang   `xml:"http://www.w3.org/XML/1998/namespace lang,attr,omitempty" json:"lang,omitempty" db:"lang"`
}

type NameComponentType struct {
	Value   string `xml:",chardata"`
	Initial string `xml:"initial,attr,omitempty" json:"initial,omitempty" db:"initial"`
	Abbrev  string `xml:"abbrev,attr,omitempty" json:"abbrev,omitempty" db:"abbrev"`
	Lang    Lang   `xml:"http://www.w3.org/XML/1998/namespace lang,attr,omitempty" json:"lang,omitempty" db:"lang"`
}

type NameTerm struct {
	Name       []Name        `xml:"urn:mpeg:mpeg7:schema:2001 Name,omitempty" json:"Name,omitempty" db:"Name"`
	Definition []TextualType `xml:"urn:mpeg:mpeg7:schema:2001 Definition,omitempty" json:"Definition,omitempty" db:"Definition"`
	Type       Type          `xml:"type,attr,omitempty" json:"type,omitempty" db:"type"`
}

type OrganizationType struct {
	Icon              []MediaLocatorType     `xml:"urn:mpeg:mpeg7:schema:2001 Icon,omitempty" json:"Icon,omitempty" db:"Icon"`
	Name              []Anon11               `xml:"urn:mpeg:mpeg7:schema:2001 Name,omitempty" json:"Name,omitempty" db:"Name"`
	NameTerm          []NameTerm             `xml:"urn:mpeg:mpeg7:schema:2001 NameTerm,omitempty" json:"NameTerm,omitempty" db:"NameTerm"`
	Kind              *TermUseType           `xml:"urn:mpeg:mpeg7:schema:2001 Kind,omitempty" json:"Kind,omitempty" db:"Kind"`
	Contact           *AgentType             `xml:"urn:mpeg:mpeg7:schema:2001 Contact,omitempty" json:"Contact,omitempty" db:"Contact"`
	ContactRef        *ReferenceType         `xml:"urn:mpeg:mpeg7:schema:2001 ContactRef,omitempty" json:"ContactRef,omitempty" db:"ContactRef"`
	Jurisdiction      *PlaceType             `xml:"urn:mpeg:mpeg7:schema:2001 Jurisdiction,omitempty" json:"Jurisdiction,omitempty" db:"Jurisdiction"`
	JurisdictionRef   *ReferenceType         `xml:"urn:mpeg:mpeg7:schema:2001 JurisdictionRef,omitempty" json:"JurisdictionRef,omitempty" db:"JurisdictionRef"`
	Address           *PlaceType             `xml:"urn:mpeg:mpeg7:schema:2001 Address,omitempty" json:"Address,omitempty" db:"Address"`
	AddressRef        *ReferenceType         `xml:"urn:mpeg:mpeg7:schema:2001 AddressRef,omitempty" json:"AddressRef,omitempty" db:"AddressRef"`
	ElectronicAddress *ElectronicAddressType `xml:"urn:mpeg:mpeg7:schema:2001 ElectronicAddress,omitempty" json:"ElectronicAddress,omitempty" db:"ElectronicAddress"`
	TimeBase          string                 `xml:"timeBase,attr,omitempty" json:"timeBase,omitempty" db:"timeBase"`
	TimeUnit          DurationType           `xml:"timeUnit,attr,omitempty" json:"timeUnit,omitempty" db:"timeUnit"`
}

type ParentalGuidance struct {
	ParentalRating  *ControlledTermUseType `xml:"urn:mpeg:mpeg7:schema:2001 ParentalRating,omitempty" json:"ParentalRating,omitempty" db:"ParentalRating"`
	MinimumAge      *int                   `xml:"urn:mpeg:mpeg7:schema:2001 MinimumAge,omitempty" json:"MinimumAge,omitempty" db:"MinimumAge"`
	Region          []RegionCode           `xml:"urn:mpeg:mpeg7:schema:2001 Region,omitempty" json:"Region,omitempty" db:"Region"`
	PreferenceValue int                    `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
}

func (t *ParentalGuidance) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T ParentalGuidance
	var overlay struct {
		*T
		PreferenceValue *int `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
	}
	overlay.T = (*T)(t)
	overlay.PreferenceValue = (*int)(&overlay.T.PreferenceValue)
	return d.DecodeElement(&overlay, &start)
}

type ParentalGuidanceType struct {
	ParentalRating *ControlledTermUseType `xml:"urn:mpeg:mpeg7:schema:2001 ParentalRating,omitempty" json:"ParentalRating,omitempty" db:"ParentalRating"`
	MinimumAge     *int                   `xml:"urn:mpeg:mpeg7:schema:2001 MinimumAge,omitempty" json:"MinimumAge,omitempty" db:"MinimumAge"`
	Region         []RegionCode           `xml:"urn:mpeg:mpeg7:schema:2001 Region,omitempty" json:"Region,omitempty" db:"Region"`
}

type PersonGroupType struct {
	Icon              []MediaLocatorType     `xml:"urn:mpeg:mpeg7:schema:2001 Icon,omitempty" json:"Icon,omitempty" db:"Icon"`
	Name              []Anon13               `xml:"urn:mpeg:mpeg7:schema:2001 Name,omitempty" json:"Name,omitempty" db:"Name"`
	NameTerm          []Anon15               `xml:"urn:mpeg:mpeg7:schema:2001 NameTerm,omitempty" json:"NameTerm,omitempty" db:"NameTerm"`
	Kind              *TermUseType           `xml:"urn:mpeg:mpeg7:schema:2001 Kind,omitempty" json:"Kind,omitempty" db:"Kind"`
	Member            *PersonType            `xml:"urn:mpeg:mpeg7:schema:2001 Member,omitempty" json:"Member,omitempty" db:"Member"`
	MemberRef         *ReferenceType         `xml:"urn:mpeg:mpeg7:schema:2001 MemberRef,omitempty" json:"MemberRef,omitempty" db:"MemberRef"`
	Jurisdiction      *PlaceType             `xml:"urn:mpeg:mpeg7:schema:2001 Jurisdiction,omitempty" json:"Jurisdiction,omitempty" db:"Jurisdiction"`
	JurisdictionRef   *ReferenceType         `xml:"urn:mpeg:mpeg7:schema:2001 JurisdictionRef,omitempty" json:"JurisdictionRef,omitempty" db:"JurisdictionRef"`
	Address           *PlaceType             `xml:"urn:mpeg:mpeg7:schema:2001 Address,omitempty" json:"Address,omitempty" db:"Address"`
	AddressRef        *ReferenceType         `xml:"urn:mpeg:mpeg7:schema:2001 AddressRef,omitempty" json:"AddressRef,omitempty" db:"AddressRef"`
	ElectronicAddress *ElectronicAddressType `xml:"urn:mpeg:mpeg7:schema:2001 ElectronicAddress,omitempty" json:"ElectronicAddress,omitempty" db:"ElectronicAddress"`
	TimeBase          string                 `xml:"timeBase,attr,omitempty" json:"timeBase,omitempty" db:"timeBase"`
	TimeUnit          DurationType           `xml:"timeUnit,attr,omitempty" json:"timeUnit,omitempty" db:"timeUnit"`
}

type PersonNameType struct {
	GivenName   *NameComponentType `xml:"urn:mpeg:mpeg7:schema:2001 GivenName,omitempty" json:"GivenName,omitempty" db:"GivenName"`
	LinkingName *NameComponentType `xml:"urn:mpeg:mpeg7:schema:2001 LinkingName,omitempty" json:"LinkingName,omitempty" db:"LinkingName"`
	FamilyName  *NameComponentType `xml:"urn:mpeg:mpeg7:schema:2001 FamilyName,omitempty" json:"FamilyName,omitempty" db:"FamilyName"`
	Title       *NameComponentType `xml:"urn:mpeg:mpeg7:schema:2001 Title,omitempty" json:"Title,omitempty" db:"Title"`
	Salutation  *NameComponentType `xml:"urn:mpeg:mpeg7:schema:2001 Salutation,omitempty" json:"Salutation,omitempty" db:"Salutation"`
	Numeration  *string            `xml:"urn:mpeg:mpeg7:schema:2001 Numeration,omitempty" json:"Numeration,omitempty" db:"Numeration"`
	DateFrom    TimePointType      `xml:"dateFrom,attr,omitempty" json:"dateFrom,omitempty" db:"dateFrom"`
	DateTo      TimePointType      `xml:"dateTo,attr,omitempty" json:"dateTo,omitempty" db:"dateTo"`
	Type        Type               `xml:"type,attr,omitempty" json:"type,omitempty" db:"type"`
	Lang        Lang               `xml:"http://www.w3.org/XML/1998/namespace lang,attr,omitempty" json:"lang,omitempty" db:"lang"`
}

type PersonType struct {
	Icon              []MediaLocatorType      `xml:"urn:mpeg:mpeg7:schema:2001 Icon,omitempty" json:"Icon,omitempty" db:"Icon"`
	Name              *PersonNameType         `xml:"urn:mpeg:mpeg7:schema:2001 Name,omitempty" json:"Name,omitempty" db:"Name"`
	NameTerm          *ControlledTermUseType  `xml:"urn:mpeg:mpeg7:schema:2001 NameTerm,omitempty" json:"NameTerm,omitempty" db:"NameTerm"`
	Affiliation       []Affiliation           `xml:"urn:mpeg:mpeg7:schema:2001 Affiliation,omitempty" json:"Affiliation,omitempty" db:"Affiliation"`
	Citizenship       []CountryCode           `xml:"urn:mpeg:mpeg7:schema:2001 Citizenship,omitempty" json:"Citizenship,omitempty" db:"Citizenship"`
	Address           *PlaceType              `xml:"urn:mpeg:mpeg7:schema:2001 Address,omitempty" json:"Address,omitempty" db:"Address"`
	AddressRef        *ReferenceType          `xml:"urn:mpeg:mpeg7:schema:2001 AddressRef,omitempty" json:"AddressRef,omitempty" db:"AddressRef"`
	ElectronicAddress []ElectronicAddressType `xml:"urn:mpeg:mpeg7:schema:2001 ElectronicAddress,omitempty" json:"ElectronicAddress,omitempty" db:"ElectronicAddress"`
	PersonDescription *TextualType            `xml:"urn:mpeg:mpeg7:schema:2001 PersonDescription,omitempty" json:"PersonDescription,omitempty" db:"PersonDescription"`
	Nationality       *CountryCode            `xml:"urn:mpeg:mpeg7:schema:2001 Nationality,omitempty" json:"Nationality,omitempty" db:"Nationality"`
	TimeBase          string                  `xml:"timeBase,attr,omitempty" json:"timeBase,omitempty" db:"timeBase"`
	TimeUnit          DurationType            `xml:"timeUnit,attr,omitempty" json:"timeUnit,omitempty" db:"timeUnit"`
}

type Pixel struct {
	Resolution  int     `xml:"resolution,attr,omitempty" json:"resolution,omitempty" db:"resolution"`
	AspectRatio float64 `xml:"aspectRatio,attr,omitempty" json:"aspectRatio,omitempty" db:"aspectRatio"`
	BitsPer     int     `xml:"bitsPer,attr,omitempty" json:"bitsPer,omitempty" db:"bitsPer"`
}

type PlaceType struct {
	Name                []TextualType           `xml:"urn:mpeg:mpeg7:schema:2001 Name,omitempty" json:"Name,omitempty" db:"Name"`
	NameTerm            []ControlledTermUseType `xml:"urn:mpeg:mpeg7:schema:2001 NameTerm,omitempty" json:"NameTerm,omitempty" db:"NameTerm"`
	Role                *TermUseType            `xml:"urn:mpeg:mpeg7:schema:2001 Role,omitempty" json:"Role,omitempty" db:"Role"`
	GeographicPosition  *GeographicPosition     `xml:"urn:mpeg:mpeg7:schema:2001 GeographicPosition,omitempty" json:"GeographicPosition,omitempty" db:"GeographicPosition"`
	Region              []RegionCode            `xml:"urn:mpeg:mpeg7:schema:2001 Region,omitempty" json:"Region,omitempty" db:"Region"`
	AdministrativeUnit  []AdministrativeUnit    `xml:"urn:mpeg:mpeg7:schema:2001 AdministrativeUnit,omitempty" json:"AdministrativeUnit,omitempty" db:"AdministrativeUnit"`
	PostalAddress       *PostalAddress          `xml:"urn:mpeg:mpeg7:schema:2001 PostalAddress,omitempty" json:"PostalAddress,omitempty" db:"PostalAddress"`
	InternalCoordinates *string                 `xml:"urn:mpeg:mpeg7:schema:2001 InternalCoordinates,omitempty" json:"InternalCoordinates,omitempty" db:"InternalCoordinates"`
	Lang                Lang                    `xml:"http://www.w3.org/XML/1998/namespace lang,attr,omitempty" json:"lang,omitempty" db:"lang"`
	TimeBase            string                  `xml:"timeBase,attr,omitempty" json:"timeBase,omitempty" db:"timeBase"`
	TimeUnit            DurationType            `xml:"timeUnit,attr,omitempty" json:"timeUnit,omitempty" db:"timeUnit"`
}

type PostalAddress struct {
	AddressLine       []TextualType `xml:"urn:mpeg:mpeg7:schema:2001 AddressLine" json:"AddressLine" db:"AddressLine"`
	PostingIdentifier *TextualType  `xml:"urn:mpeg:mpeg7:schema:2001 PostingIdentifier,omitempty" json:"PostingIdentifier,omitempty" db:"PostingIdentifier"`
	Lang              Lang          `xml:"http://www.w3.org/XML/1998/namespace lang,attr,omitempty" json:"lang,omitempty" db:"lang"`
}

type PreferenceCondition struct {
	Place *PlaceType   `xml:"urn:mpeg:mpeg7:schema:2001 Place,omitempty" json:"Place,omitempty" db:"Place"`
	Time  []Time       `xml:"urn:mpeg:mpeg7:schema:2001 Time,omitempty" json:"Time,omitempty" db:"Time"`
	Genre *TermUseType `xml:"urn:mpeg:mpeg7:schema:2001 Genre,omitempty" json:"Genre,omitempty" db:"Genre"`
}

type PreferenceConditionType struct {
	Place *PlaceType `xml:"urn:mpeg:mpeg7:schema:2001 Place,omitempty" json:"Place,omitempty" db:"Place"`
	Time  []Time     `xml:"urn:mpeg:mpeg7:schema:2001 Time,omitempty" json:"Time,omitempty" db:"Time"`
}

type PreferenceValueType int

type PresentationManifestLocator struct {
	Location    string   `xml:",chardata" db:"location" json:"location"`
	ManifestId  string   `xml:"manifestId,attr" json:"manifestId" db:"manifestId"`
	ContentType MimeType `xml:"contentType,attr" json:"contentType" db:"contentType"`
}

func (t *PresentationManifestLocator) Scan(src interface{}) error {
	if src == nil {
		return nil
	}

	// Handle scanning from text format (used in Postgres composite types)
	switch v := src.(type) {
	case string:
		return t.scanFromString(v)
	case []byte:
		return t.scanFromString(string(v))
	}

	return fmt.Errorf("cannot scan %T into PresentationManifestLocator", src)
}

func (t *PresentationManifestLocator) scanFromString(src string) error {
	// Parse PostgreSQL composite type format: (field1,field2,field3)
	// Remove parentheses and split by comma, handling escaped commas
	if len(src) < 2 || src[0] != '(' || src[len(src)-1] != ')' {
		return fmt.Errorf("invalid format for PresentationManifestLocator: %s", src)
	}

	// Remove parentheses
	src = src[1 : len(src)-1]

	// Simple split - in a production system you'd want more robust parsing
	parts := strings.SplitN(src, ",", 3)
	if len(parts) != 3 {
		return fmt.Errorf("expected 3 fields in PresentationManifestLocator, got %d", len(parts))
	}

	// Unquote strings if needed
	t.Location = unquoteIfNeeded(parts[0])
	t.ManifestId = unquoteIfNeeded(parts[1])
	t.ContentType = MimeType(unquoteIfNeeded(parts[2]))

	return nil
}

// Helper function to handle quoted values in PostgreSQL composite types
func unquoteIfNeeded(s string) string {
	s = strings.TrimSpace(s)
	if len(s) >= 2 && s[0] == '"' && s[len(s)-1] == '"' {
		// Remove quotes and unescape any double quotes inside
		s = s[1 : len(s)-1]
		s = strings.ReplaceAll(s, "\"\"", "\"") // Postgres escapes quotes by doubling them
	}
	return s
}

func (t PresentationManifestLocator) Value() (driver.Value, error) {
	// Format as PostgreSQL composite type
	location := quoteIfNeeded(t.Location)
	manifestId := quoteIfNeeded(t.ManifestId)
	contentType := quoteIfNeeded(string(t.ContentType))

	return fmt.Sprintf("(%s,%s,%s)", location, manifestId, contentType), nil
}

// Helper function to quote values for PostgreSQL composite types
func quoteIfNeeded(s string) string {
	// Quote values that contain special characters
	if strings.ContainsAny(s, ", ()\"\\") {
		s = strings.ReplaceAll(s, "\"", "\"\"") // Escape quotes
		s = "\"" + s + "\""
	}
	return s
}

type ProbabilityVector []float64

func (x *ProbabilityVector) MarshalText() ([]byte, error) {
	result := make([][]byte, 0, len(*x))
	for _, v := range *x {
		s := strconv.FormatFloat(v, 'g', -1, 64)
		result = append(result, []byte(s))
	}
	return bytes.Join(result, []byte(" ")), nil
}
func (x *ProbabilityVector) UnmarshalText(text []byte) error {
	for _, v := range strings.Fields(string(text)) {
		if f, err := strconv.ParseFloat(v, 64); err != nil {
			return err
		} else {
			*x = append(*x, f)
		}
	}
	return nil
}

type RatingScheme struct {
	Name       []Name        `xml:"urn:mpeg:mpeg7:schema:2001 Name,omitempty" json:"Name,omitempty" db:"Name"`
	Definition []TextualType `xml:"urn:mpeg:mpeg7:schema:2001 Definition,omitempty" json:"Definition,omitempty" db:"Definition"`
	Best       float32       `xml:"best,attr,omitempty" json:"best,omitempty" db:"best"`
	Worst      float32       `xml:"worst,attr,omitempty" json:"worst,omitempty" db:"worst"`
	Style      Style         `xml:"style,attr" json:"style" db:"style"`
}

type RatingType struct {
	RatingValue  float32      `xml:"urn:mpeg:mpeg7:schema:2001 RatingValue" json:"RatingValue" db:"RatingValue"`
	RatingScheme RatingScheme `xml:"urn:mpeg:mpeg7:schema:2001 RatingScheme" json:"RatingScheme" db:"RatingScheme"`
}

type Recurrence string

type ReferenceType struct {
	Idref string `xml:"idref,attr,omitempty" json:"idref,omitempty" db:"idref"`
}

// Must match the pattern [a-zA-Z]{2}(-[a-zA-Z0-9]{1,3})?
type RegionCode string

type RelIncrTimePointType struct {
	Value    int          `xml:",chardata"`
	TimeUnit DurationType `xml:"timeUnit,attr,omitempty" json:"timeUnit,omitempty" db:"timeUnit"`
	TimeBase string       `xml:"timeBase,attr,omitempty" json:"timeBase,omitempty" db:"timeBase"`
}

type RelTimePointType struct {
	TimeOffsetType TimeOffsetType `xml:",chardata"`
	TimeBase       string         `xml:"timeBase,attr,omitempty" json:"timeBase,omitempty" db:"timeBase"`
}

type ReportingLocatorType struct {
	Value       string  `xml:",chardata"`
	Proportion  float64 `xml:"proportion,attr,omitempty" json:"proportion,omitempty" db:"proportion"`
	Period      string  `xml:"period,attr" json:"period" db:"period"`
	RandomDelay uint    `xml:"randomDelay,attr" json:"randomDelay" db:"randomDelay"`
}

func (t *ReportingLocatorType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T ReportingLocatorType
	var overlay struct {
		*T
		Proportion *float64 `xml:"proportion,attr,omitempty" json:"proportion,omitempty" db:"proportion"`
	}
	overlay.T = (*T)(t)
	overlay.Proportion = (*float64)(&overlay.T.Proportion)
	return d.DecodeElement(&overlay, &start)
}

type Review struct {
	Rating          *RatingType `xml:"urn:mpeg:mpeg7:schema:2001 Rating,omitempty" json:"Rating,omitempty" db:"Rating"`
	Reviewer        *AgentType  `xml:"urn:mpeg:mpeg7:schema:2001 Reviewer,omitempty" json:"Reviewer,omitempty" db:"Reviewer"`
	PreferenceValue int         `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
}

func (t *Review) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T Review
	var overlay struct {
		*T
		PreferenceValue *int `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
	}
	overlay.T = (*T)(t)
	overlay.PreferenceValue = (*int)(&overlay.T.PreferenceValue)
	return d.DecodeElement(&overlay, &start)
}

type Sample struct {
	Rate    float64 `xml:"rate,attr,omitempty" json:"rate,omitempty" db:"rate"`
	BitsPer int     `xml:"bitsPer,attr,omitempty" json:"bitsPer,omitempty" db:"bitsPer"`
}

type SessionReportingType struct {
	ReportingLocator []ReportingLocatorType `xml:"urn:dvb:metadata:MulticastSessionConfiguration:2019 ReportingLocator" json:"ReportingLocator" db:"ReportingLocator"`
}

type SourcePreferencesType struct {
	DisseminationFormat   []DisseminationFormat   `xml:"urn:mpeg:mpeg7:schema:2001 DisseminationFormat,omitempty" json:"DisseminationFormat,omitempty" db:"DisseminationFormat"`
	DisseminationSource   []DisseminationSource   `xml:"urn:mpeg:mpeg7:schema:2001 DisseminationSource,omitempty" json:"DisseminationSource,omitempty" db:"DisseminationSource"`
	DisseminationLocation []DisseminationLocation `xml:"urn:mpeg:mpeg7:schema:2001 DisseminationLocation,omitempty" json:"DisseminationLocation,omitempty" db:"DisseminationLocation"`
	DisseminationDate     []DisseminationDate     `xml:"urn:mpeg:mpeg7:schema:2001 DisseminationDate,omitempty" json:"DisseminationDate,omitempty" db:"DisseminationDate"`
	Disseminator          []Disseminator          `xml:"urn:mpeg:mpeg7:schema:2001 Disseminator,omitempty" json:"Disseminator,omitempty" db:"Disseminator"`
	MediaFormat           []MediaFormat           `xml:"urn:mpeg:mpeg7:schema:2001 MediaFormat,omitempty" json:"MediaFormat,omitempty" db:"MediaFormat"`
	NoRepeat              bool                    `xml:"noRepeat,attr,omitempty" json:"noRepeat,omitempty" db:"noRepeat"`
	NoEncryption          bool                    `xml:"noEncryption,attr,omitempty" json:"noEncryption,omitempty" db:"noEncryption"`
	NoPayPerUse           bool                    `xml:"noPayPerUse,attr,omitempty" json:"noPayPerUse,omitempty" db:"noPayPerUse"`
	PreferenceValue       int                     `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
	TimeBase              string                  `xml:"timeBase,attr,omitempty" json:"timeBase,omitempty" db:"timeBase"`
	TimeUnit              DurationType            `xml:"timeUnit,attr,omitempty" json:"timeUnit,omitempty" db:"timeUnit"`
}

func (t *SourcePreferencesType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T SourcePreferencesType
	var overlay struct {
		*T
		PreferenceValue *int `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
	}
	overlay.T = (*T)(t)
	overlay.PreferenceValue = (*int)(&overlay.T.PreferenceValue)
	return d.DecodeElement(&overlay, &start)
}

// Must match the pattern [^\r\n\t \p{Z}]*
type StringNoWhitespaceType string

// May be one of progressive, interlaced
type Structure string

// May be one of higherBetter, lowerBetter
type Style string

type Subject struct {
	Value           string `xml:",chardata"`
	PreferenceValue int    `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
	Lang            Lang   `xml:"http://www.w3.org/XML/1998/namespace lang,attr,omitempty" json:"lang,omitempty" db:"lang"`
}

func (t *Subject) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T Subject
	var overlay struct {
		*T
		PreferenceValue *int `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
	}
	overlay.T = (*T)(t)
	overlay.PreferenceValue = (*int)(&overlay.T.PreferenceValue)
	return d.DecodeElement(&overlay, &start)
}

type SummaryComponentType string

type SummaryPreferencesType struct {
	SummaryType        []SummaryType      `xml:"urn:mpeg:mpeg7:schema:2001 SummaryType,omitempty" json:"SummaryType,omitempty" db:"SummaryType"`
	SummaryTheme       []SummaryTheme     `xml:"urn:mpeg:mpeg7:schema:2001 SummaryTheme,omitempty" json:"SummaryTheme,omitempty" db:"SummaryTheme"`
	SummaryDuration    *MediaDurationType `xml:"urn:mpeg:mpeg7:schema:2001 SummaryDuration,omitempty" json:"SummaryDuration,omitempty" db:"SummaryDuration"`
	MinSummaryDuration *MediaDurationType `xml:"urn:mpeg:mpeg7:schema:2001 MinSummaryDuration,omitempty" json:"MinSummaryDuration,omitempty" db:"MinSummaryDuration"`
	MaxSummaryDuration *MediaDurationType `xml:"urn:mpeg:mpeg7:schema:2001 MaxSummaryDuration,omitempty" json:"MaxSummaryDuration,omitempty" db:"MaxSummaryDuration"`
	NumOfKeyFrames     *int               `xml:"urn:mpeg:mpeg7:schema:2001 NumOfKeyFrames,omitempty" json:"NumOfKeyFrames,omitempty" db:"NumOfKeyFrames"`
	MinNumOfKeyFrames  *int               `xml:"urn:mpeg:mpeg7:schema:2001 MinNumOfKeyFrames,omitempty" json:"MinNumOfKeyFrames,omitempty" db:"MinNumOfKeyFrames"`
	MaxNumOfKeyFrames  *int               `xml:"urn:mpeg:mpeg7:schema:2001 MaxNumOfKeyFrames,omitempty" json:"MaxNumOfKeyFrames,omitempty" db:"MaxNumOfKeyFrames"`
	NumOfChars         *int               `xml:"urn:mpeg:mpeg7:schema:2001 NumOfChars,omitempty" json:"NumOfChars,omitempty" db:"NumOfChars"`
	MinNumOfChars      *int               `xml:"urn:mpeg:mpeg7:schema:2001 MinNumOfChars,omitempty" json:"MinNumOfChars,omitempty" db:"MinNumOfChars"`
	MaxNumOfChars      *int               `xml:"urn:mpeg:mpeg7:schema:2001 MaxNumOfChars,omitempty" json:"MaxNumOfChars,omitempty" db:"MaxNumOfChars"`
	PreferenceValue    int                `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
	TimeBase           string             `xml:"timeBase,attr,omitempty" json:"timeBase,omitempty" db:"timeBase"`
	TimeUnit           DurationType       `xml:"timeUnit,attr,omitempty" json:"timeUnit,omitempty" db:"timeUnit"`
}

func (t *SummaryPreferencesType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T SummaryPreferencesType
	var overlay struct {
		*T
		PreferenceValue *int `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
	}
	overlay.T = (*T)(t)
	overlay.PreferenceValue = (*int)(&overlay.T.PreferenceValue)
	return d.DecodeElement(&overlay, &start)
}

type SummaryTheme struct {
	Value           string `xml:",chardata"`
	PreferenceValue int    `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
	Lang            Lang   `xml:"http://www.w3.org/XML/1998/namespace lang,attr,omitempty" json:"lang,omitempty" db:"lang"`
}

func (t *SummaryTheme) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T SummaryTheme
	var overlay struct {
		*T
		PreferenceValue *int `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
	}
	overlay.T = (*T)(t)
	overlay.PreferenceValue = (*int)(&overlay.T.PreferenceValue)
	return d.DecodeElement(&overlay, &start)
}

type SummaryType struct {
	SummaryComponentType SummaryComponentType `xml:",chardata"`
	PreferenceValue      int                  `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
}

func (t *SummaryType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T SummaryType
	var overlay struct {
		*T
		PreferenceValue *int `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
	}
	overlay.T = (*T)(t)
	overlay.PreferenceValue = (*int)(&overlay.T.PreferenceValue)
	return d.DecodeElement(&overlay, &start)
}

type Telephone struct {
	Value string `xml:",chardata"`
	Type  Type   `xml:"type,attr,omitempty" json:"type,omitempty" db:"type"`
}

type TemporalSegmentLocatorType struct {
	MediaUri     *string          `xml:"urn:mpeg:mpeg7:schema:2001 MediaUri,omitempty" json:"MediaUri,omitempty" db:"MediaUri"`
	InlineMedia  *InlineMediaType `xml:"urn:mpeg:mpeg7:schema:2001 InlineMedia,omitempty" json:"InlineMedia,omitempty" db:"InlineMedia"`
	StreamID     *int             `xml:"urn:mpeg:mpeg7:schema:2001 StreamID,omitempty" json:"StreamID,omitempty" db:"StreamID"`
	MediaTime    *MediaTimeType   `xml:"urn:mpeg:mpeg7:schema:2001 MediaTime,omitempty" json:"MediaTime,omitempty" db:"MediaTime"`
	BytePosition *Anon4           `xml:"urn:mpeg:mpeg7:schema:2001 BytePosition,omitempty" json:"BytePosition,omitempty" db:"BytePosition"`
}

type Term struct {
	Name       []Anon5                   `xml:"urn:mpeg:mpeg7:schema:2001 Name,omitempty" json:"Name,omitempty" db:"Name"`
	Definition []TextualType             `xml:"urn:mpeg:mpeg7:schema:2001 Definition,omitempty" json:"Definition,omitempty" db:"Definition"`
	Term       []Term                    `xml:"urn:mpeg:mpeg7:schema:2001 Term,omitempty" json:"Term,omitempty" db:"Term"`
	Relation   TermRelationQualifierType `xml:"relation,attr,omitempty" json:"relation,omitempty" db:"relation"`
	TermID     string                    `xml:"termID,attr,omitempty" json:"termID,omitempty" db:"termID"`
	TimeBase   string                    `xml:"timeBase,attr,omitempty" json:"timeBase,omitempty" db:"timeBase"`
	TimeUnit   DurationType              `xml:"timeUnit,attr,omitempty" json:"timeUnit,omitempty" db:"timeUnit"`
}

func (t *Term) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T Term
	var overlay struct {
		*T
		Relation *TermRelationQualifierType `xml:"relation,attr,omitempty" json:"relation,omitempty" db:"relation"`
	}
	overlay.T = (*T)(t)
	overlay.Relation = (*TermRelationQualifierType)(&overlay.T.Relation)
	return d.DecodeElement(&overlay, &start)
}

type TermDefinitionBaseType struct {
	Name       []Anon5       `xml:"urn:mpeg:mpeg7:schema:2001 Name,omitempty" json:"Name,omitempty" db:"Name"`
	Definition []TextualType `xml:"urn:mpeg:mpeg7:schema:2001 Definition,omitempty" json:"Definition,omitempty" db:"Definition"`
	TermID     string        `xml:"termID,attr,omitempty" json:"termID,omitempty" db:"termID"`
	TimeBase   string        `xml:"timeBase,attr,omitempty" json:"timeBase,omitempty" db:"timeBase"`
	TimeUnit   DurationType  `xml:"timeUnit,attr,omitempty" json:"timeUnit,omitempty" db:"timeUnit"`
}

type TermDefinitionType struct {
	Name       []Anon5       `xml:"urn:mpeg:mpeg7:schema:2001 Name,omitempty" json:"Name,omitempty" db:"Name"`
	Definition []TextualType `xml:"urn:mpeg:mpeg7:schema:2001 Definition,omitempty" json:"Definition,omitempty" db:"Definition"`
	Term       []Term        `xml:"urn:mpeg:mpeg7:schema:2001 Term,omitempty" json:"Term,omitempty" db:"Term"`
	TermID     string        `xml:"termID,attr,omitempty" json:"termID,omitempty" db:"termID"`
	TimeBase   string        `xml:"timeBase,attr,omitempty" json:"timeBase,omitempty" db:"timeBase"`
	TimeUnit   DurationType  `xml:"timeUnit,attr,omitempty" json:"timeUnit,omitempty" db:"timeUnit"`
}

type TermReferenceType string

type TermRelationQualifierType string

type TermUseType struct {
	Name       []Name        `xml:"urn:mpeg:mpeg7:schema:2001 Name,omitempty" json:"Name,omitempty" db:"Name"`
	Definition []TextualType `xml:"urn:mpeg:mpeg7:schema:2001 Definition,omitempty" json:"Definition,omitempty" db:"Definition"`
}

type TextualBaseType struct {
	Value string `xml:",chardata"`
	Lang  Lang   `xml:"http://www.w3.org/XML/1998/namespace lang,attr,omitempty" json:"lang,omitempty" db:"lang"`
}

type TextualType struct {
	Value string `xml:",chardata"`
	Lang  Lang   `xml:"http://www.w3.org/XML/1998/namespace lang,attr,omitempty" json:"lang,omitempty" db:"lang"`
}

type Time struct {
	TimePoint        *TimePointType        `xml:"urn:mpeg:mpeg7:schema:2001 TimePoint,omitempty" json:"TimePoint,omitempty" db:"TimePoint"`
	RelTimePoint     *RelTimePointType     `xml:"urn:mpeg:mpeg7:schema:2001 RelTimePoint,omitempty" json:"RelTimePoint,omitempty" db:"RelTimePoint"`
	RelIncrTimePoint *RelIncrTimePointType `xml:"urn:mpeg:mpeg7:schema:2001 RelIncrTimePoint,omitempty" json:"RelIncrTimePoint,omitempty" db:"RelIncrTimePoint"`
	Duration         *DurationType         `xml:"urn:mpeg:mpeg7:schema:2001 Duration,omitempty" json:"Duration,omitempty" db:"Duration"`
	IncrDuration     *IncrDurationType     `xml:"urn:mpeg:mpeg7:schema:2001 IncrDuration,omitempty" json:"IncrDuration,omitempty" db:"IncrDuration"`
	Recurrence       Recurrence            `xml:"recurrence,attr,omitempty" json:"recurrence,omitempty" db:"recurrence"`
	NumOfRecurrences int                   `xml:"numOfRecurrences,attr,omitempty" json:"numOfRecurrences,omitempty" db:"numOfRecurrences"`
}

func (t *Time) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T Time
	var overlay struct {
		*T
		Recurrence *Recurrence `xml:"recurrence,attr,omitempty" json:"recurrence,omitempty" db:"recurrence"`
	}
	overlay.T = (*T)(t)
	overlay.Recurrence = (*Recurrence)(&overlay.T.Recurrence)
	return d.DecodeElement(&overlay, &start)
}

// Must match the pattern \-?P(\d+D)?(T(\d+H)?(\d+M)?(\d+S)?(\d+N)?)?(\d+F)?((\-|\+)\d{2}:\d{2}Z)?
type TimeOffsetType string

// Must match the pattern (\-?\d+(\-\d{2}(\-\d{2})?)?)?(T\d{2}(:\d{2}(:\d{2}(:\d+)?)?)?)?(F\d+)?((\-|\+)\d{2}:\d{2})?
type TimePointType string

type TimeType struct {
	TimePoint        *TimePointType        `xml:"urn:mpeg:mpeg7:schema:2001 TimePoint,omitempty" json:"TimePoint,omitempty" db:"TimePoint"`
	RelTimePoint     *RelTimePointType     `xml:"urn:mpeg:mpeg7:schema:2001 RelTimePoint,omitempty" json:"RelTimePoint,omitempty" db:"RelTimePoint"`
	RelIncrTimePoint *RelIncrTimePointType `xml:"urn:mpeg:mpeg7:schema:2001 RelIncrTimePoint,omitempty" json:"RelIncrTimePoint,omitempty" db:"RelIncrTimePoint"`
	Duration         *DurationType         `xml:"urn:mpeg:mpeg7:schema:2001 Duration,omitempty" json:"Duration,omitempty" db:"Duration"`
	IncrDuration     *IncrDurationType     `xml:"urn:mpeg:mpeg7:schema:2001 IncrDuration,omitempty" json:"IncrDuration,omitempty" db:"IncrDuration"`
}

type Title struct {
	Value           string `xml:",chardata"`
	PreferenceValue int    `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
	Type            Type   `xml:"type,attr,omitempty" json:"type,omitempty" db:"type"`
	Lang            Lang   `xml:"http://www.w3.org/XML/1998/namespace lang,attr,omitempty" json:"lang,omitempty" db:"lang"`
}

func (t *Title) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T Title
	var overlay struct {
		*T
		PreferenceValue *int  `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
		Type            *Type `xml:"type,attr,omitempty" json:"type,omitempty" db:"type"`
	}
	overlay.T = (*T)(t)
	overlay.PreferenceValue = (*int)(&overlay.T.PreferenceValue)
	overlay.Type = (*Type)(&overlay.T.Type)
	return d.DecodeElement(&overlay, &start)
}

type TitleMediaType struct {
	TitleImage *ImageLocatorType           `xml:"urn:mpeg:mpeg7:schema:2001 TitleImage,omitempty" json:"TitleImage,omitempty" db:"TitleImage"`
	TitleVideo *TemporalSegmentLocatorType `xml:"urn:mpeg:mpeg7:schema:2001 TitleVideo,omitempty" json:"TitleVideo,omitempty" db:"TitleVideo"`
	TitleAudio *TemporalSegmentLocatorType `xml:"urn:mpeg:mpeg7:schema:2001 TitleAudio,omitempty" json:"TitleAudio,omitempty" db:"TitleAudio"`
}

type TitleType struct {
	Value string `xml:",chardata"`
	Type  Type   `xml:"type,attr,omitempty" json:"type,omitempty" db:"type"`
	Lang  Lang   `xml:"http://www.w3.org/XML/1998/namespace lang,attr,omitempty" json:"lang,omitempty" db:"lang"`
}

func (t *TitleType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T TitleType
	var overlay struct {
		*T
		Type *Type `xml:"type,attr,omitempty" json:"type,omitempty" db:"type"`
	}
	overlay.T = (*T)(t)
	overlay.Type = (*Type)(&overlay.T.Type)
	return d.DecodeElement(&overlay, &start)
}

type Tool struct {
	Name            []Name        `xml:"urn:mpeg:mpeg7:schema:2001 Name,omitempty" json:"Name,omitempty" db:"Name"`
	Definition      []TextualType `xml:"urn:mpeg:mpeg7:schema:2001 Definition,omitempty" json:"Definition,omitempty" db:"Definition"`
	PreferenceValue int           `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
}

func (t *Tool) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T Tool
	var overlay struct {
		*T
		PreferenceValue *int `xml:"preferenceValue,attr,omitempty" json:"preferenceValue,omitempty" db:"preferenceValue"`
	}
	overlay.T = (*T)(t)
	overlay.PreferenceValue = (*int)(&overlay.T.PreferenceValue)
	return d.DecodeElement(&overlay, &start)
}

// May be one of resource, chunked
type TransmissionModeType string

// May be one of none, integrity, integrityAndAuthenticity
type TransportSecurityType string

// May be one of former, variant, main
type Type string

// A URL and accompanying MIME content type.
type TypedLocatorType struct {
	Value       string   `xml:",chardata"`
	ContentType MimeType `xml:"contentType,attr" json:"contentType" db:"contentType"`
}

// An element describing the parameters to be used by a Multicast gateway when
// performing unicast repair. One or more base paths may be specified here, each with an optional weighting. If the
// weighting is omitted, all base paths are assumed to have an equal weighting of 1.0.
type UnicastRepairParametersType struct {
	BaseURL                         []WeightedURIType `xml:"urn:dvb:metadata:MulticastSessionConfiguration:2019 BaseURL,omitempty" json:"BaseURL,omitempty" db:"BaseURL"`
	TransportObjectReceptionTimeout uint              `xml:"transportObjectReceptionTimeout,attr" json:"transportObjectReceptionTimeout" db:"transportObjectReceptionTimeout"`
	FixedBackOffPeriod              uint              `xml:"fixedBackOffPeriod,attr,omitempty" json:"fixedBackOffPeriod,omitempty" db:"fixedBackOffPeriod"`
	RandomBackOffPeriod             uint              `xml:"randomBackOffPeriod,attr,omitempty" json:"randomBackOffPeriod,omitempty" db:"randomBackOffPeriod"`
	TransportObjectBaseURI          string            `xml:"transportObjectBaseURI,attr,omitempty" json:"transportObjectBaseURI,omitempty" db:"transportObjectBaseURI"`
}

func (t *UnicastRepairParametersType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T UnicastRepairParametersType
	var overlay struct {
		*T
		FixedBackOffPeriod  *uint `xml:"fixedBackOffPeriod,attr,omitempty" json:"fixedBackOffPeriod,omitempty" db:"fixedBackOffPeriod"`
		RandomBackOffPeriod *uint `xml:"randomBackOffPeriod,attr,omitempty" json:"randomBackOffPeriod,omitempty" db:"randomBackOffPeriod"`
	}
	overlay.T = (*T)(t)
	overlay.FixedBackOffPeriod = (*uint)(&overlay.T.FixedBackOffPeriod)
	overlay.RandomBackOffPeriod = (*uint)(&overlay.T.RandomBackOffPeriod)
	return d.DecodeElement(&overlay, &start)
}

type UniqueIDType struct {
	Value        string   `xml:",chardata"`
	Type         string   `xml:"type,attr,omitempty" json:"type,omitempty" db:"type"`
	Organization string   `xml:"organization,attr,omitempty" json:"organization,omitempty" db:"organization"`
	Authority    string   `xml:"authority,attr,omitempty" json:"authority,omitempty" db:"authority"`
	Encoding     Encoding `xml:"encoding,attr,omitempty" json:"encoding,omitempty" db:"encoding"`
}

func (t *UniqueIDType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T UniqueIDType
	var overlay struct {
		*T
		Type     *string   `xml:"type,attr,omitempty" json:"type,omitempty" db:"type"`
		Encoding *Encoding `xml:"encoding,attr,omitempty" json:"encoding,omitempty" db:"encoding"`
	}
	overlay.T = (*T)(t)
	overlay.Type = (*string)(&overlay.T.Type)
	overlay.Encoding = (*Encoding)(&overlay.T.Encoding)
	return d.DecodeElement(&overlay, &start)
}

type UsageHistoryType struct {
	UserIdentifier    *UserIdentifierType     `xml:"urn:mpeg:mpeg7:schema:2001 UserIdentifier,omitempty" json:"UserIdentifier,omitempty" db:"UserIdentifier"`
	UserActionHistory []UserActionHistoryType `xml:"urn:mpeg:mpeg7:schema:2001 UserActionHistory" json:"UserActionHistory" db:"UserActionHistory"`
	AllowCollection   UserChoiceType          `xml:"allowCollection,attr,omitempty" json:"allowCollection,omitempty" db:"allowCollection"`
	TimeBase          string                  `xml:"timeBase,attr,omitempty" json:"timeBase,omitempty" db:"timeBase"`
	TimeUnit          DurationType            `xml:"timeUnit,attr,omitempty" json:"timeUnit,omitempty" db:"timeUnit"`
}

func (t *UsageHistoryType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T UsageHistoryType
	var overlay struct {
		*T
		AllowCollection *UserChoiceType `xml:"allowCollection,attr,omitempty" json:"allowCollection,omitempty" db:"allowCollection"`
	}
	overlay.T = (*T)(t)
	overlay.AllowCollection = (*UserChoiceType)(&overlay.T.AllowCollection)
	return d.DecodeElement(&overlay, &start)
}

type UserActionHistoryType struct {
	ObservationPeriod []TimeType           `xml:"urn:mpeg:mpeg7:schema:2001 ObservationPeriod,omitempty" json:"ObservationPeriod,omitempty" db:"ObservationPeriod"`
	UserActionList    []UserActionListType `xml:"urn:mpeg:mpeg7:schema:2001 UserActionList" json:"UserActionList" db:"UserActionList"`
	Protected         UserChoiceType       `xml:"protected,attr,omitempty" json:"protected,omitempty" db:"protected"`
	TimeBase          string               `xml:"timeBase,attr,omitempty" json:"timeBase,omitempty" db:"timeBase"`
	TimeUnit          DurationType         `xml:"timeUnit,attr,omitempty" json:"timeUnit,omitempty" db:"timeUnit"`
}

func (t *UserActionHistoryType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T UserActionHistoryType
	var overlay struct {
		*T
		Protected *UserChoiceType `xml:"protected,attr,omitempty" json:"protected,omitempty" db:"protected"`
	}
	overlay.T = (*T)(t)
	overlay.Protected = (*UserChoiceType)(&overlay.T.Protected)
	return d.DecodeElement(&overlay, &start)
}

type UserActionListType struct {
	ActionType     TermUseType      `xml:"urn:mpeg:mpeg7:schema:2001 ActionType" json:"ActionType" db:"ActionType"`
	UserAction     []UserActionType `xml:"urn:mpeg:mpeg7:schema:2001 UserAction,omitempty" json:"UserAction,omitempty" db:"UserAction"`
	NumOfInstances int              `xml:"numOfInstances,attr,omitempty" json:"numOfInstances,omitempty" db:"numOfInstances"`
	TotalDuration  DurationType     `xml:"totalDuration,attr,omitempty" json:"totalDuration,omitempty" db:"totalDuration"`
	TimeBase       string           `xml:"timeBase,attr,omitempty" json:"timeBase,omitempty" db:"timeBase"`
	TimeUnit       DurationType     `xml:"timeUnit,attr,omitempty" json:"timeUnit,omitempty" db:"timeUnit"`
}

type UserActionType struct {
	ActionTime        *ActionTime     `xml:"urn:mpeg:mpeg7:schema:2001 ActionTime,omitempty" json:"ActionTime,omitempty" db:"ActionTime"`
	ProgramIdentifier UniqueIDType    `xml:"urn:mpeg:mpeg7:schema:2001 ProgramIdentifier" json:"ProgramIdentifier" db:"ProgramIdentifier"`
	ActionDataItem    []ReferenceType `xml:"urn:mpeg:mpeg7:schema:2001 ActionDataItem,omitempty" json:"ActionDataItem,omitempty" db:"ActionDataItem"`
	TimeBase          string          `xml:"timeBase,attr,omitempty" json:"timeBase,omitempty" db:"timeBase"`
	TimeUnit          DurationType    `xml:"timeUnit,attr,omitempty" json:"timeUnit,omitempty" db:"timeUnit"`
}

// May be one of true, false, user
type UserChoiceType string

type UserIdentifierType struct {
	Name      TextualType    `xml:"urn:mpeg:mpeg7:schema:2001 Name" json:"Name" db:"Name"`
	Protected UserChoiceType `xml:"protected,attr,omitempty" json:"protected,omitempty" db:"protected"`
}

func (t *UserIdentifierType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T UserIdentifierType
	var overlay struct {
		*T
		Protected *UserChoiceType `xml:"protected,attr,omitempty" json:"protected,omitempty" db:"protected"`
	}
	overlay.T = (*T)(t)
	overlay.Protected = (*UserChoiceType)(&overlay.T.Protected)
	return d.DecodeElement(&overlay, &start)
}

type UserPreferencesType struct {
	UserIdentifier                *UserIdentifierType                 `xml:"urn:mpeg:mpeg7:schema:2001 UserIdentifier,omitempty" json:"UserIdentifier,omitempty" db:"UserIdentifier"`
	FilteringAndSearchPreferences []FilteringAndSearchPreferencesType `xml:"urn:mpeg:mpeg7:schema:2001 FilteringAndSearchPreferences,omitempty" json:"FilteringAndSearchPreferences,omitempty" db:"FilteringAndSearchPreferences"`
	BrowsingPreferences           []BrowsingPreferencesType           `xml:"urn:mpeg:mpeg7:schema:2001 BrowsingPreferences,omitempty" json:"BrowsingPreferences,omitempty" db:"BrowsingPreferences"`
	AllowAutomaticUpdate          UserChoiceType                      `xml:"allowAutomaticUpdate,attr,omitempty" json:"allowAutomaticUpdate,omitempty" db:"allowAutomaticUpdate"`
	TimeBase                      string                              `xml:"timeBase,attr,omitempty" json:"timeBase,omitempty" db:"timeBase"`
	TimeUnit                      DurationType                        `xml:"timeUnit,attr,omitempty" json:"timeUnit,omitempty" db:"timeUnit"`
}

func (t *UserPreferencesType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T UserPreferencesType
	var overlay struct {
		*T
		AllowAutomaticUpdate *UserChoiceType `xml:"allowAutomaticUpdate,attr,omitempty" json:"allowAutomaticUpdate,omitempty" db:"allowAutomaticUpdate"`
	}
	overlay.T = (*T)(t)
	overlay.AllowAutomaticUpdate = (*UserChoiceType)(&overlay.T.AllowAutomaticUpdate)
	return d.DecodeElement(&overlay, &start)
}

type VisualCoding struct {
	Format *Format `xml:"urn:mpeg:mpeg7:schema:2001 Format,omitempty" json:"Format,omitempty" db:"Format"`
	Pixel  *Pixel  `xml:"urn:mpeg:mpeg7:schema:2001 Pixel,omitempty" json:"Pixel,omitempty" db:"Pixel"`
	Frame  *Frame  `xml:"urn:mpeg:mpeg7:schema:2001 Frame,omitempty" json:"Frame,omitempty" db:"Frame"`
}

// A URI with an associated weighting attribute.
type WeightedURIType struct {
	Value          string `xml:",chardata"`
	RelativeWeight int    `xml:"relativeWeight,attr,omitempty" json:"relativeWeight,omitempty" db:"relativeWeight"`
}

func (t *WeightedURIType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type T WeightedURIType
	var overlay struct {
		*T
		RelativeWeight *int `xml:"relativeWeight,attr,omitempty" json:"relativeWeight,omitempty" db:"relativeWeight"`
	}
	overlay.T = (*T)(t)
	overlay.RelativeWeight = (*int)(&overlay.T.RelativeWeight)
	return d.DecodeElement(&overlay, &start)
}

type XPathAbsoluteSelectorType string

type XPathSelectorType string

type XPathType string

type xsdBase64Binary []byte

func (b *xsdBase64Binary) UnmarshalText(text []byte) (err error) {
	*b, err = base64.StdEncoding.DecodeString(string(text))
	return
}
func (b xsdBase64Binary) MarshalText() ([]byte, error) {
	var buf bytes.Buffer
	enc := base64.NewEncoder(base64.StdEncoding, &buf)
	enc.Write([]byte(b))
	enc.Close()
	return buf.Bytes(), nil
}

type xsdHexBinary []byte

func (b *xsdHexBinary) UnmarshalText(text []byte) (err error) {
	*b, err = hex.DecodeString(string(text))
	return
}
func (b xsdHexBinary) MarshalText() ([]byte, error) {
	n := hex.EncodedLen(len(b))
	buf := make([]byte, n)
	hex.Encode(buf, []byte(b))
	return buf, nil
}
